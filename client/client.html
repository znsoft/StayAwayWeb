<!doctype html>
<meta charset=utf-8>

<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="UTF-8">
</head>
<title>Нечто</title>

<style>
    * {
        box-sizing: border-box;
    }

    html {
        height: 100%;
    }

    body {
        background-color: #61a0a0;
        height: 100%;
        margin: 0;
        padding: 0;
    }

    canvas {
        display: block;
        width: 100%;
        height: 100%;
        touch-action: manipulation;
    }

    button,
    select,
    a,
    a:visited {
        padding: 8px 12px;
        border: 0px;
        border-radius: 5px;
        margin-right: 5px;
        color: #FFFFFF;
        background-color: #000000;
        font-family: monospace;
        font-size: 11px;
        cursor: pointer;
        text-decoration: none;
        text-transform: uppercase;
    }

    button:hover,
    select:hover,
    a:hover {
        background-color: #FFFFFF;
        color: #000000;
    }

    img {
        padding: 4px;
        border: 0px;
        border-radius: 5px;
        margin-right: 5px;
        background-color: #000000;
        vertical-align: middle;
        cursor: pointer;
        image-rendering: pixelated;
    }

    img:hover {
        background-color: #FFFFFF;
    }

    option {
        color: #ffffff;
        background-color: #000000;
    }

    #toolbar {
        transition: opacity 1s;
    }


    *[data-tooltip] {
        position: relative;
    }

    *[data-tooltip]::after {
        content: attr(data-tooltip);

        position: absolute;
        top: +20px;
        right: -100px;
        width: 250px;

        pointer-events: none;
        opacity: 0;
        -webkit-transition: opacity .15s ease-in-out;
        -moz-transition: opacity .15s ease-in-out;
        -ms-transition: opacity .15s ease-in-out;
        -o-transition: opacity .15s ease-in-out;
        transition: opacity .15s ease-in-out;

        display: block;
        font-size: 12px;
        line-height: 16px;
        background: #fefdcd;
        padding: 2px 2px;
        border: 1px solid #eb9c09;
        box-shadow: 2px 4px 5px rgba(0, 0, 0, 0.4);
    }

    *[data-tooltip]:hover::after {
        opacity: 1;
    }
</style>

<body>


    <button id="logoutbutton" onclick="LogoutGame()" hidden="true" data-tooltip="Выйти из игры">Выйти из игры</button>
    <div style="opacity: 0.74; position: absolute; transition: opacity 1s;">
        <textarea id="gamelog" style="opacity: 0.74; transition: opacity 1s;" cols="35" rows="15"
            onclick="console.log('click')" readonly="true"></textarea><br>
        <textarea id="chat" style="opacity: 0.74; transition: opacity 1s;" cols="35" rows="15"
            onclick="console.log('click')" readonly="true"></textarea><br>
        <input id="chatmessage" width="40" onkeydown="chat(this)"></input><button id="chatbutton"
            onclick="sendChat()">Отправить</button>
        <div id="logindiv">
            <br><br>
            Комната:<input id="room" value="1"></input>
            Ваше имя:<input id="login"></input>
            <button id="loginbutton" onclick="sendLogin()">Войти</button>

            <button id="startgamebutton" hidden="true" onclick="startGame()"
                data-tooltip="Подождите пока подключатся все игроки">Начать игру</button>



        </div>

    </div>
    <canvas id="canvas" width="2000" height="2000">
        Please update your browser<br> in order
        to
        view this page.</canvas>


</body>

<script>



    var canvas = document.getElementById("canvas");
    canvas.height = window.innerHeight;
    canvas.width = window.innerWidth;

    var ctx = canvas.getContext("2d");
    ctx.globalCompositeOperation = 'destination-over';
    var w = canvas.width;
    var h = canvas.height;



    CanvasRenderingContext2D.prototype.measureText = function (text, font) {
        const span = document.createElement('span');
        span.appendChild(document.createTextNode(text));
        Object.assign(span.style, {
            font: font,
            margin: '0',
            padding: '0',
            border: '0'
            , whiteSpace: 'pre-line'

        });
        document.body.appendChild(span);
        const { width, height } = span.getBoundingClientRect();
        span.remove();
        return { width, height };
    }


    CanvasRenderingContext2D.prototype.drawPoint = function (x, y, circleRadius, fillStyle, labels) {
        if (labels == "" || labels == undefined || labels == null) return;
        if (typeof (labels) != "string") return;
        this.beginPath();

        this.drawTooltip(x, y, labels);

        this.fillStyle = fillStyle;

        var point = new Path2D();

        point.arc(x, y, circleRadius, 0, 2 * Math.PI);

        this.fill(point);


        this.closePath();
    }


    CanvasRenderingContext2D.prototype.drawTooltip = function (x, y, label, alignY = 25) {

        const { width, height } = this.measureText(label, '20px Arial, Helvetica, sans-serif');

        const reactWidth = width + 10;
        const reactHeight = height + 10;
        const reactX = x + 12;
        const reactY = y - alignY;
        const labelX = reactX + ((reactWidth - width) / 2);
        const labelY = reactY + 22;

        this.beginPath();

        this.font = '20px Arial, Helvetica, sans-serif';
        let y1 = labelY;
        this.strokeStyle = 'red';
        this.fillStyle = "white";
        let labels = label.split("\n").forEach(s => {

            this.fillText(s, labelX, y1);
            y1 += alignY;
        });
        // this.strokeText(label, labelX, labelY);
        this.fillStyle = "green";
        this.strokeStyle = 'green';
        this.roundRect(reactX, reactY, reactWidth, reactHeight, 10).fill();


        //this.fillRect(reactX, reactY, reactWidth, reactHeight);


        this.closePath();
    }


    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
    };

    CanvasRenderingContext2D.prototype.getWindowToCanvas = function (e) {
        if (e == undefined) return;
        //first calculate normal mouse coordinates
        e = e || window.event;
        var target = e.target || e.srcElement,
            style = target.currentStyle || window.getComputedStyle(target, null),
            borderLeftWidth = parseInt(style["borderLeftWidth"], 10),
            borderTopWidth = parseInt(style["borderTopWidth"], 10),
            rect = target.getBoundingClientRect(),
            offsetX = e.clientX - borderLeftWidth - rect.left,
            offsetY = e.clientY - borderTopWidth - rect.top;
        let x = (offsetX * target.width) / target.clientWidth;
        let y = (offsetY * target.height) / target.clientHeight;


        var transform = this.getTransform();
        const invMat = transform.invertSelf();
        return {
            x: x * invMat.a + y * invMat.c + invMat.e,
            y: x * invMat.b + y * invMat.d + invMat.f
        };
    }

    CanvasRenderingContext2D.prototype.getCanvasToWindow = function (x, y) {

        var invMat = this.getTransform();
        //const invMat = transform.invertSelf();
        return {
            x: x * invMat.a + y * invMat.c + invMat.e,
            y: x * invMat.b + y * invMat.d + invMat.f
        };
    }

    window.shaderlog = {};

    class Shadertoy {

        load(fragmentUrl) {

            if (typeof (window.localStorage) === "undefined") {

                if (typeof (window.shaderlog[fragmentUrl]) === 'undefined') {
                    var xmlhttp = new XMLHttpRequest();
                    xmlhttp.open("GET", fragmentUrl, false);
                    xmlhttp.send();
                    if ((xmlhttp.status === 200)) {
                        window.shaderlog[fragmentUrl] = xmlhttp.responseText;
                        this.fragSrc = xmlhttp.responseText;
                    }
                } else {
                    this.fragSrc = window.shaderlog[fragmentUrl];
                }
                return;
            }


            if (window["localStorage"]["getItem"](fragmentUrl) === null || parseInt(window["localStorage"]["getItem"](fragmentUrl).split('\u0003')[1], 16) < window["Date"]["now"]()) {
                var xmlhttp = new XMLHttpRequest();
                xmlhttp.open("GET", fragmentUrl, false);
                xmlhttp.send();
                if ((xmlhttp.status === 200)) {
                    window["localStorage"]["setItem"](fragmentUrl, xmlhttp.responseText + "\u0003" + ((86400000) + window["Date"]["now"]()).toString(16));
                    this.fragSrc = xmlhttp.responseText;
                }
            } else {
                this.fragSrc = window["localStorage"]["getItem"](fragmentUrl).split('\u0003')[0];
            }
        }







        constructor(shader) {

            this.a = document.createElement("canvas");
            //this.a.hidden = false;
            //this.d;
            this.g = this.a.getContext('webgl');
            // GUI: canvas
            //this.a.style = 'width:100%;height:100vh;float:left';
            this.fragSrc = shader;
            this.load(shader);
            this.o = (new Date / 1e3);

            this.g.u = this.g.uniform1f;
            this.g.uv = this.g.uniform2f;

            this.p = this.g.createProgram();

            // Basic vertex shader
            // shaderSource(s=createShader(VERTEX_SHADER),"attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}");
            let s = this.g.createShader(35633);
            this.g.shaderSource(s, 'attribute vec2 p;void main(){gl_Position=vec4(p,1,1);}');

            // Compile and attach it to the program
            // compileShader(s);
            this.g.compileShader(s);

            // DEBUGS
            if (!this.g.getShaderParameter(s, this.g.COMPILE_STATUS)) {
                this.g.getShaderInfoLog(s).trim().split("\n").forEach(ss =>
                    console.warn("[vertex shader] " + ss))
                //throw new Error("Error while compiling shader")
            };


            //attachShader(p,s);
            this.g.attachShader(this.p, s);

            // Main program
            // shaderSource(s=createShader(FRAGMENT_SHADER),'...');
            let s1 = this.g.createShader(35632);
            this.g.shaderSource(s1, this.fragSrc);
            //this.g.shaderSource(s1 ,'precision mediump float;uniform float t,a,x,y;void main(){vec3 f=vec3(gl_FragCoord.rg/640.-.5,1.);f.g*=a;float c=.5+x/500.,v=.5+y/500.;mat2 m=mat2(cos(c),sin(c),-sin(c),cos(c)),s=mat2(cos(v),sin(v),-sin(v),cos(v));f.rb*=m;f.rg*=s;vec3 r=vec3(1.,.5,.5);r+=vec3(t*2.,t,-2.);r.rb*=m;r.rg*=s;float g=.1,b=1.;vec3 i=vec3(0.);for(int l=0;l<20;l++){vec3 o=r+g*f*.5;o=abs(vec3(1.)-mod(o,vec3(2.)));float e,n=e=0.;for(int d=0;d<20;d++)o=abs(o)/dot(o,o)-.53,n+=abs(length(o)-e),e=length(o);if(l>6)b*=1.-max(0.,.3-n*n*.001);i+=b+vec3(g,g*g,g*g*g*g)*n*n*n*.0015*b;b*=.73;g+=.1;}i=mix(vec3(length(i)),i,.85);gl_FragColor=vec4(i*.01,1.);}');

            // Compile and attach it to the program
            // compileShader(s);
            this.g.compileShader(s1);

            // DEBUGS
            if (!this.g.getShaderParameter(s1, this.g.COMPILE_STATUS)) {
                this.g.getShaderInfoLog(s1).trim().split("\n").forEach(ss =>
                    console.warn("[fragment shader] " + ss))
                //throw new Error("Error while compiling shader")
            };

            // attachShader(p,s);
            this.g.attachShader(this.p, s1);

            // Link and start the program
            //linkProgram(P);
            this.g.linkProgram(this.p);

            //useProgram(p);
            this.g.useProgram(this.p);

            // Define a big triangle the canvas, containing the viewport
            // bindBuffer(g=ARRAY_BUFFER, createBuffer());
            let g = 34962;
            this.g.bindBuffer(g, this.g.createBuffer());

            // enableVertexAttribArray(0);
            this.g.enableVertexAttribArray(0);

            // vertexAttribPointer(0, 2, BYTE, 0, 0, 0);
            this.g.vertexAttribPointer(0, 2, 5120, 0, 0, 0);

            // bufferData(g,new Int8Array([-3, 1, 1, -3, 1, 1]), STATIC_DRAW);
            this.g.bufferData(g, new Int8Array([-3, 1, 1, -3, 1, 1]), 35044);
            this.Draw();
        }

        Draw(e, w, h) {
            e = e || window.event;
            this.a.height = w;
            this.a.width = h;
            this.g.viewport(0, 0, w, h);
            // Current playback time (in 1/200 seconds)
            this.g.u(this.g.getUniformLocation(this.p, 't'), (new Date / 1e3) - this.o);
            this.g.u(this.g.getUniformLocation(this.p, 'time'), (new Date / 1e3) - this.o);
            this.g.uv(this.g.getUniformLocation(this.p, 'resolution'), w, h);
            if (e != undefined) this.g.uv(this.g.getUniformLocation(this.p, 'mouse'), e.clientX, e.clientY);

            // Current sapect ration
            this.g.u(this.g.getUniformLocation(this.p, 'a'), h / w);

            // Mouse coordinates
            //this.g.u(this.g.getUniformLocation(this.p,'x'), x);
            //u(gf(p,'y'), y);

            // Draw
            // drawArrays(TRIANGLE_FAN,0,3);
            this.g.drawArrays(6, 0, 3);

            return this.a;
        }



    }


    class Button {
        //static height = 
        constructor(id, text, x, y, w, h, callback, p) {
            this.id = id;
            this.text = text;
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            this.callback = callback;
            Button.buttons.set(id, this);
            this.p = p;
            //this.p1 = p1;

        }

        static buttons = new Map();

        static add() {


        }

        static DrawAll(ctx, e) {
            Button.buttons.forEach((v, k) => v.Draw(ctx, e));

        }

        static Delete(id) {
            Button.buttons.delete(id);

        }

        static DeleteAll() {
            Button.buttons.clear();
        }

        Draw(ctx, e) {
            ctx.save();
            ctx.translate(this.x, this.y);

            ctx.fillStyle = "#000";
            ctx.font = '16px serif';
            ctx.fillText(this.text, 3, 16);
            ctx.roundRect(0, 0, this.w, this.h, 5).stroke();
            ctx.fillStyle = "green";
            ctx.roundRect(0, 0, this.w, this.h, 5).fill();//stroke();
            // if (e != undefined) {
            if (e != undefined && e.type != 'mousemove') {
                let c = ctx.getWindowToCanvas(e);

                if (c != undefined)
                    if (c.x > 0 && c.x < this.w && c.y > 0 && c.y < this.h && this.callback != undefined) {

                        this.callback(this.p); game.me.selected = null; game.moveOneCard = false;
                    }
            }
            ctx.restore();

        }

    }




    class Animator {
        static easetime = 0.3;
        static frames = 1000;
        static moves = new Map();
        constructor(card, from, to) {
            this.ctx = undefined;
            this.isMove = false;
            this.card = card;
            this.from = from;
            this.to = to;
            this.endpos = null;
            this.startpos = null;
            this.t = Animator.easetime;
            this.speed = this.t / Animator.frames;

            this.currentpos = null;

            this.starttime = Date.now();
            Animator.moves.set(card, this);


        }

        static EndGame() {
            let cards = game.Deck.cardsLeft;
            for (let t = 0; t < Math.random() * 88; t++) {


                let str = {
                    isMove: true,
                    from: {
                        type: "deck",
                    },
                    to: {
                        type: "coord",
                        x: Math.random() * game.width,
                        y: Math.random() * game.height
                    }

                };

                Animator.AddCardmove(new Card(Cards.Thing, "deck", 0, str), str.from, str.to);

            }



        }

        static AddCardmove(card, from, to) {
            new Animator(card, from, to);
        }


        static IsNotMove(card) {
            let a = Animator.moves.get(card);
            if (a == undefined) return true;
            //if(a.isMove == true)return false;
            return false;
        }

        static DrawAll(ctx, game) {
            Animator.moves.forEach((v, k) => {
                if (v.isMove == false) {
                    v.StartMove(Animator.getPosition(game, v.from), Animator.getPosition(game, v.to));
                    //v.Move(ctx);
                } else
                    v.Move(ctx);
            });


        }

        static getPosition(game, fromto) {
            if (fromto == undefined) return;
            //let coord = {x:player.x,y:player.y};
            let c = undefined;
            switch (fromto.type) {
                case "player":
                    let player = game.findPlayerByNum(fromto.player);
                    let coord = { x: player.x, y: player.y };

                    c = player.findCardByPlace(fromto.place);
                    if (c != undefined) coord = { x: c.x, y: c.y };
                    return coord;

                    break;
                case "deck":
                    c = game.Deck.getDeckCard();
                    if (c != undefined) return { x: c.x, y: c.y };
                    break;
                case "drop":
                    c = game.Deck.getDropCard();
                    if (c != undefined) return { x: c.x, y: c.y };
                    break;
                case "table":
                    c = game.Deck.getTableCard();
                    if (c != undefined) return { x: c.x, y: c.y };
                    break;
                case "door":

                    break;
                case "coord":
                    return fromto;

                    break;

            }


        }


        StartMove(startpos, endpos) {
            if (this.isMove == true) return;
            if (startpos == undefined) { Animator.Delete(this.card); return; }
            if (endpos == undefined) { Animator.Delete(this.card); return; }
            this.startpos = startpos; this.currentPos = startpos;
            this.endpos = endpos;
            this.delta = { x: endpos.x - startpos.x, y: endpos.y - startpos.y };
            this.len = Math.max(Math.abs(this.delta.x), Math.abs(this.delta.y));
            if (this.len > 1000) this.len = 1000;
            this.starttime = Date.now();
            this.t = Animator.easetime * this.len;
            this.isMove = true;
            setTimeout(() => {
                //console.log("endmove");
                Animator.Delete(this.card);
            }, this.t);

        }


        Draw(ctx) {

            ctx.save();

            ctx.translate(this.currentpos.x, this.currentpos.y);
            //console.log(this.currentpos);
            this.card.card.Draw(ctx);
            ctx.restore();
        }


        Move(ctx) {
            let deltatime = (Date.now() - this.starttime) / this.t;

            this.currentpos = { x: this.startpos.x + (this.delta.x * deltatime), y: this.startpos.y + (this.delta.y * deltatime) };
            this.Draw(ctx);

        }


        static Delete(card) {
            Animator.moves.delete(card);

        }

        static DeleteAll() {
            Animator.moves.clear();
        }


    }

    class Deck {



        constructor(upCard, cardsLeft, dropCount, drop = [], table = [], deck) {
            this.tableMove = {};
            this.dropMove = {};
            this.doorsMove = [];
            this.deckMove = {};



            this.upCard = new Card(findCardByNum(upCard), "deck", 0, {});
            this.cardsLeft = cardsLeft;
            this.Doors = [];
            this.Drop = dropCount;
            this.x = 0;
            this.y = 0;
            this.dropX = 0;
            this.dropY = 0;


            this.drop = drop.reverse().map((v, i) => new Card(findCardByNum(v), "drop", i, {}));
            this.table = table == undefined ? [] : table.map((v, i) => new Card(findCardByNum(v), "table", i, {}));
            if (deck == undefined) return;
            if (deck.dropmove != undefined) Animator.AddCardmove(this.drop[0], deck.dropmove.from, deck.dropmove.to);
            if (deck.tablemove != undefined) Animator.AddCardmove(this.table[0], deck.tablemove.from, deck.tablemove.to);
            if (deck.deckmove != undefined) Animator.AddCardmove(this.upCard, deck.deckmove.from, deck.deckmove.to);


        }

        getDropCard() {

            if (this.drop.length == 0) return undefined;
            return this.drop[0];


        }

        getTableCard() {

            if (this.table.length == 0) return undefined;
            return this.table[0];


        }

        getDeckCard() {

            return this.upCard;


        }

        Draw(ctx, e) {
            let scrDeck = ctx.getCanvasToWindow(0, 0);
            this.x = scrDeck.x;//this.transform.e;
            this.y = scrDeck.y;//this.transform.f
            ctx.save();
            // ctx.globalCompositeOperation = 'destination-over';
            ctx.translate(this.cardsLeft * 2, this.cardsLeft * 2);
            ctx.rotate(Math.PI / 2);
            this.upCard.Draw(ctx, e);

            ctx.restore();

            for (let i = this.cardsLeft; i > 1; i--) {

                ctx.save();
                ctx.translate(i * 2, i * 2);
                ctx.rotate(Math.PI / 2);
                Cards.UnknownAction.Draw(ctx);
                ctx.restore();
            }


            ctx.save();
            // ctx.globalCompositeOperation = 'destination-over';
            ctx.translate(0, 100);
            //ctx.rotate(Math.PI / 2);

            this.table.forEach((v, i) => {

                ctx.save();
                ctx.translate(i * 102, i * 2);
                //ctx.rotate(Math.PI / 2);
                v.Draw(ctx, e);
                ctx.restore();

            });


            ctx.restore();


            ctx.save();
            // ctx.globalCompositeOperation = 'destination-over';
            ctx.translate(200, -50);


            this.drop.forEach((v, i) => {

                ctx.save();
                ctx.translate(i * 1, i * 1 + 40);
                ctx.rotate(Math.PI / 1.5 + i / 120);
                v.Draw(ctx);

                ctx.restore();


            });


            ctx.rotate(Math.PI / 2.5);
            ctx.fillStyle = "#000";
            ctx.font = '16px serif';
            ctx.fillText("Сброс", 10, 20);
            ctx.roundRect(0, 0, 95, 150, 10).stroke();
            //if (this.Drop == 0)Cards.UnknownAction.Draw(ctx);

            ctx.restore();




        }

    };



    class TextLabels {

        constructor(id, text, x = 0, y = undefined, c = "#000", s = 1, t = 3000) {
            this.id = id;
            this.text = text;
            this.x = x;
            this.y = y;
            this.c = c;
            this.s = s;
            this.t = t;
            this.isHint = false;
            this.e = undefined;
            TextLabels.labels.set(id, this);

            if (t > 0) setTimeout(() => {
                TextLabels.Delete(id);
            }, t);


        }
        static lastY = 230;
        static offsetY = 0;
        static labels = new Map();

        static hint(x, y, text, c) {
            let tl = new TextLabels("Hint", text, x, y, c, 1, 0);
            tl.isHint = true;

        }



        static ErrorLabelText(text) {
            TextLabels.lastY = game.height / 2 + 100;
            new TextLabels(TextLabels.labels.size, text, game.width / 2 + 100);//, 0, TextLabels.lastY);


        }

        static DrawAll(ctx, e) {
            let offset = 0;
            TextLabels.labels.forEach((v, k) => { offset = v.Draw(ctx, e, offset) });
            //TextLabels.lastY -= 17;
        }

        static Delete(id) {
            TextLabels.labels.delete(id);

        }

        static DeleteAll() {
            TextLabels.labels.clear();
        }

        Draw(ctx, e, offset = 0) {
            let y = this.y;
            let l = 0;
            if (this.y == undefined) y = TextLabels.lastY;
            y += offset;

            ctx.save();
            ctx.translate(this.x, y);
            ctx.fillStyle = this.c;
            ctx.font = '16px serif';
            ctx.scale(this.s, this.s);
            ctx.strokeStyle = 'white';
            // this.fillStyle = "white";

            if (this.text != undefined)
                if (this.isHint) {
                    ctx.drawPoint(this.x, this.y, 5, this.c, this.text);
                    //ctx.drawPoint(this.x, this.y, 5, this.c, [this.text.replace("\n","<br>")]);
                } else
                    for (var s of this.text.split("\n")) {
                        //ctx.strokeText(s, 0, l += 17);
                        ctx.fillText(s, 0, l += 17);//+= 17);
                    }

            //TextLabels.lastY = y;
            ctx.restore();
            //ctx.fillText(this.text);//, 3, this.text.length);
            return l + offset;

        }


    }





    class CardType {
        static width = 95;
        static height = 150;
        static splace = 0;
        constructor(name, num, CardCaption, Description, img, Exchange, Answer, Action, SecondAction, isPanic = false, isUnknown = false) {
            this.name = name;
            this.num = num;
            this.isPanic = isPanic;
            this.isUnknown = isUnknown;
            this.CardCaption = CardCaption;
            this.Description = Description;
            this.img = new Image();
            this.img.src = img;
            this.Exchange = Exchange;//алгоритм который возвращает допустимые кнопки в фазе начала обмена относительно выбранной карты на своей руке
            this.Answer = Answer; //алгоритм который возвращает допустимые кнопки в фазе ответа относительно выбранной карты на своей руке
            this.Action = Action;//алгоритм который возвращает допустимые кнопки в фазе действия  относительно выбранной карты на своей руке
            this.SecondAction = SecondAction; //алгоритм который возвращает допустимые кнопки в фазе продолжения действия относительно карты на столе 
            CardType.splace++;
            this.place = CardType.splace;
            //this.opponent = null;//?????  opponent in card ???
            this.x = 0;
            this.y = 0;
        }



        GetActionArray(player) {
            if (this.Action == null) return [];
            let check = null;
            if (Array.isArray(this.Action)) check = this.Action; else check = [this.Action];
            if (typeof (this.Action) == "function") check = this.Action(player);
            if (check == null || check == undefined) return [];
            if (!Array.isArray(check)) check = [check];
            return check;

        }

        GetSecondActionArray(player, card) {
            if (this.SecondAction == null) return [];
            let check = null;
            if (Array.isArray(this.SecondAction)) check = this.SecondAction; else check = [this.SecondAction];
            if (typeof (this.SecondAction) == "function") check = this.SecondAction(player, card);
            if (check == null || check == undefined) return [];
            if (!Array.isArray(check)) check = [check];
            return check;

        }

        GetExchangeArray(player, other) {
            if (this.Exchange == null) return [];
            let check = null;
            if (Array.isArray(this.Exchange)) check = this.Exchange; else check = [this.Exchange];
            if (typeof (this.Exchange) == "function") check = this.Exchange(player, other);
            if (check == null || check == undefined) return [];
            if (!Array.isArray(check)) check = [check];
            return check;

        }

        GetAnswerArray(player, other) {
            if (this.Answer == null) return [];
            let check = null;
            if (Array.isArray(this.Answer)) check = this.Answer; else check = [this.Answer];
            if (typeof (this.Answer) == "function") check = this.Answer(player, other);
            if (check == null || check == undefined) return [];
            if (!Array.isArray(check)) check = [check];
            return check;

        }


        isCardMovableForAction(player) {
            let c = this.GetActionArray(player);
            return c.filter((v) => v.MayMove == true).length > 0;
        }

        RemoveOldAddNewButtons(player, z) {
            Button.DeleteAll();

            let c = [];
            switch (player.Phase) {
                case Phases.Nothing:


                    return;
                case Phases.Action:
                    c = this.GetActionArray(player);
                    break;
                case Phases.Exchange:
                    c = this.GetExchangeArray(player, game.opponent);//?????  opponent in card ???
                    break;

                case Phases.Answer:
                    c = this.GetAnswerArray(player, game.opponent);
                    break;
                case Phases.SecondAction:
                    game.Deck.table.forEach((v) => c = v.card.GetSecondActionArray(player, this));
                    break;


            }


            let x = 220;
            let y = 250;
            c.forEach((v) => {
                if (v.hasOwnProperty("Button")) {
                    new Button(v.Button.Text, v.Button.Text, x, y, v.Button.Text.length * 15, 30, v.Button.action, z);
                    x += v.Button.Text.length * 15 + 5;
                }
            });

        }

        Draw(ctx, e) {

            //ctx.beginPath();
            //if (this.isPanic && !this.isUnknown) ctx.scale(2.0, 2.0);
            ctx.fillStyle = "#000";
            ctx.font = '16px serif';
            //ctx.fillText(this.name, 10, 20);
            ctx.font = '16px serif';
            let y = CardType.height + 3;//16;
            for (var s of this.CardCaption.split("\n")) ctx.fillText(s, 1, y += 12);

            ctx.roundRect(0, 0, CardType.width, CardType.height, 10);


            ctx.clip();
            ctx.drawImage(this.img, 0, 0, CardType.width, CardType.height);



            ctx.fillStyle = this.isUnknown ? "#b92" : "#f5fb";
            ctx.fill();
            ctx.stroke();
            if (e != undefined) {
                let c = ctx.getWindowToCanvas(e);
                if (c != undefined)
                    if (c.x > 0 && c.x < CardType.width && c.y > 0 && c.y < CardType.height) {
                        let scr = ctx.getCanvasToWindow(c.x, c.y);
                        //                        TextLabels.hint(e.clientX/2, e.clientY/2, this.Description, 'black');
                        TextLabels.hint(scr.x / 2, scr.y / 2 - 30, this.Description, 'black');
                        if (e.type != 'mousemove')
                            return true;
                    }
            }
            return false;
        }


    };



    const Actions = {
        Nothing: { id: - 1, },
        Drop: { id: 0, Button: { Text: "Скинуть", action: dropcard }, },
        outChange: { id: 1, Button: { Text: "Обмен", action: exchangecard }, isOutExchange: true },// OnSelectAction: exchangecard },
        inChange: { id: 1, Button: { Text: "Обмен", action: exchangecardin }, isInExchange: true },// OnSelectAction: exchangecard },
        SawOneCard: { id: 2, HiLightText: "Выбери карту игрока", MayMove: true, HiLightRLPlayers: true, selectNearPlayersCards: true, actionOnSelectSecondCard: ShowMeCard },
        SawAllCards: { id: 3, HiLightText: "Выбери игрока", MayMove: true, HiLightRLPlayers: true, selectPlayer: true, OnSelectPlayer: Analysis },
        Burn: { id: 5, HiLightText: "Выбери игрока", MayMove: true, HiLightRLPlayers: true, selectPlayer: true, OnSelectPlayer: BurnPlayer },
        DefendFromFire: { id: 6, Button: { Text: "Шашлык", action: DefendFromFire } },
        exChange: { id: 7, Button: { Text: "Обмен", action: exchangecardin } },
        ShowAllCards: { id: 8, HiLightText: "Показать все карты", Button: { Text: "Использовать", action: showAllCards }, },
        Temptation: { id: 9, HiLightText: "Обмен с любым игроком", Button: { Text: "Использовать", action: useTemptation } },
        Perseverance: { id: 10, HiLightText: "Выбери карту из колоды", Button: { Text: "Использовать", action: usePerseverance } },
        NoThanks: { id: 11, HiLightText: "Отклонить обмен", Button: { Text: "Отклонить", action: nothanks } },
        ChangeDirection: { id: 12, HiLightText: "Сменить направление хода", Button: { Text: "Использовать", action: ChangeDirection }, },
        Panic: { id: 13, HiLightText: "Паника", Button: { Text: "Паника", action: Panic }, },
        ShowAllCardsTo: { id: 14, HiLightText: "Выбери игрока", selectPlayer: true, OnSelectPlayer: ShowAllCardsToPlayer },
        SelectCardForDeck: { id: 15, Button: { Text: "Подложить в колоду", action: PanicMeet }, },
        PanicOnlyOneCardStayInHand: { id: 16, Button: { Text: "Оставить эту карту", action: PanicForgot }, },
        Mist: { id: 17, HiLightText: "Отклонить обмен", Button: { Text: "Отклонить", action: mist } },
        Fear: { id: 18, HiLightText: "Отклонить обмен", Button: { Text: "Отклонить и посмотреть", action: fear } },
        ChangePlaceNear: { id: 19, HiLightText: "Выбери игрока", MayMove: true, HiLightRLPlayers: true, selectPlayer: true, OnSelectPlayer: ChangePlaceNear },
        inChangePlace: { id: 20, Button: { Text: "Пересесть", action: AcceptChangePlace }, isInExchangePlace: true },// OnSelectAction: exchangecard },
        StayHere: { id: 21, Button: { Text: "Остаться", action: DefendFromChangePlace }, isInExchangePlace: true },// OnSelectAction: exchangecard },
        ChangePlace: { id: 22, HiLightText: "Выбери игрока", MayMove: true, HLAllNonQuarantine: true, selectPlayer: true, OnSelectPlayer: ChangePlace },
        Quarantine: { id: 23, HiLightText: "Выбери игрока", MayMove: true, HiLightRLPlayers: true, selectPlayer: true, OnSelectPlayer: SetQuarantine },
        PanicGoAway: { id: 24, HiLightText: "Выбери игрока", MayMove: true, HLAllNonQuarantine: true, selectPlayer: true, OnSelectPlayer: PanicGoAway },
        Axe: { id: 25, HiLightText: "Выбери игрока", MayMove: true, HiLightRLPlayers: true, selectPlayer: true, OnSelectPlayer: Axe },
        Door: { id: 26, HiLightText: "Выбери игрока", MayMove: true, HiLightRLPlayers: true, selectPlayer: true, OnSelectPlayer: SetDoor },
        PanicOneTwo: { id: 27, HiLightText: "Выбери игрока", MayMove: true, HLThridPlayers: true, selectPlayer: true, OnSelectPlayer: PanicOneTwo },
        PanicConfessionTime: { id: 28, HiLightText: "Время признаний", Button: { Text: "Показать карты всем", action: PanicConfessionTime } },
        PanicNoConfessionTime: { id: 29, Button: { Text: "Не показывать карты всем", action: PanicNoConfessionTime } },
        PanicStopConfessionTime: { id: 30, Button: { Text: "Остановить время признаний", action: PanicStopConfessionTime } },
    };

    const Algoritms = {
        MayGiveInfect: function (me, other) {
            if (me.Thing == true) return Actions.outChange;
            if (me.Infected == true && other.Thing == true && me.InfectCount > 1) return Actions.outChange;
            return Actions.Nothing;
        },
        MayGiveInfectIn: function (me, other) {
            if (me.Thing == true) return Actions.inChange;
            if (me.Infected == true && other.Thing == true && me.InfectCount > 1) return Actions.inChange;
            return Actions.Nothing;
        },
        MayDropInfect: function (me) {
            if (me.Infected == true && me.InfectCount == 1) return Actions.Nothing;
            return Actions.Drop;
        },
        OnlyDropAction: (me) => Actions.Drop,
        SimpleExchange: (me, other) => Actions.outChange,
        SimpleAnswer: (me, other) => {
            if (me.state == States.IncomeExchange) return Actions.inChange;
            return Actions.Nothing;
        },
        ActionSuspicion: (me) => {
            if (me.QuarantineCount > 0) return Actions.Drop;
            return [Actions.Drop, Actions.SawOneCard]
        },
        ActionAnalysis: (me) => {
            if (me.QuarantineCount > 0) return Actions.Drop;
            return [Actions.Drop, Actions.SawAllCards]
        },
        ActionBurnFire: (me) => {
            //if (game.selectedOpponent == null) return Actions.Drop;
            if (me.QuarantineCount > 0) return Actions.Drop;
            return [Actions.Drop, Actions.Burn]
        },
        ActionWhiski: (me) => {

            if (me.QuarantineCount > 0) return Actions.Drop;
            return [Actions.Drop, Actions.ShowAllCards]
        },
        ActionTemptation: (me) => {
            if (me.QuarantineCount > 0) return Actions.Drop;
            return [Actions.Drop, Actions.Temptation]
        },
        ActionTemptation2: (me, card) => {
            if (game.selectedOpponent == null) return Actions.Nothing;
            return card.GetExchangeArray(me, game.selectedOpponent);
        },
        FireResistance: (me, other) => {
            if (me.state == States.DefendFireSelectCard) return Actions.DefendFromFire;
            return Actions.inChange;
        },
        Perseverance: (me) => {
            if (me.QuarantineCount > 0) return Actions.Drop;
            return [Actions.Drop, Actions.Perseverance]
        },
        Perseverance2: (me, card) => [],
        NoThanks: (me, other) => {
            if (me.state == States.IncomeExchange) return [Actions.inChange, Actions.NoThanks];
            return Actions.Nothing;
        },
        ChangeDirection: (me) => {
            if (me.QuarantineCount > 0) return Actions.Drop;
            return [Actions.Drop, Actions.ChangeDirection]
        },
        Panic: (me) => [Actions.Panic],
        ChainPanic: (me, card) => {
            return card.GetExchangeArray(me, game.opponent);
        },
        PanicBetweenUs: (me, card) => [Actions.ShowAllCardsTo],
        PanicGoAway: (me, card) => {
            //if(game.opponent.quarantineCount>0)return Actions.Nothing;
            return Actions.PanicGoAway
        },
        PanicMeet: (me, card) => {
            if (card == Cards.Thing) return Actions.Nothing;
            if (me.Infected == true && me.InfectCount == 1 && card == Cards.Infect) return Actions.Nothing;
            return Actions.SelectCardForDeck
        },
        PanicOnlyOneCardStayInHand: (me, card) => {
            if (me.Thing == true && card != Cards.Thing) return Actions.Nothing;
            if (me.Infected == true && me.Thing == false && card != Cards.Infect) return Actions.Nothing;
            return Actions.PanicOnlyOneCardStayInHand;
        },
        Mist: (me, other) => {
            if (me.state == States.IncomeExchange) return [Actions.inChange, Actions.Mist];
            return Actions.Nothing;
        },
        Fear: (me, other) => {
            if (me.state == States.IncomeExchange) return [Actions.inChange, Actions.Fear];
            return Actions.Nothing;
        },
        ChangePlaceNear: (me) => {
            if (me.QuarantineCount > 0) return Actions.Drop;
            return [Actions.Drop, Actions.ChangePlaceNear];
        },
        ChangePlace: (me) => {
            if (me.QuarantineCount > 0) return Actions.Drop;
            return [Actions.Drop, Actions.ChangePlace];
        },
        StayHere: (me, other) => {
            if (me.state == States.DefendPlaceChange) return [Actions.inChangePlace, Actions.StayHere];
            return Actions.inChange;
        },
        Quarantine: (me) => {
            if (me.QuarantineCount > 0) return Actions.Drop;
            return [Actions.Drop, Actions.Quarantine];
        },
        Axe: (me) => {
            return [Actions.Drop, Actions.Axe];
        },
        Door: (me) => {
            return [Actions.Drop, Actions.Door];
        },

        Friends: (me, card) => {
            return card.GetExchangeArray(me, game.opponent);
        },

        PanicOneTwo: (me, card) => {
            return Actions.PanicOneTwo;

        }
        ,
        PanicConfessionTime: (me, card) => {
            if (card == Cards.Infect) return [Actions.PanicConfessionTime, Actions.PanicNoConfessionTime, Actions.PanicStopConfessionTime];
            return [Actions.PanicConfessionTime, Actions.PanicNoConfessionTime];

        }


    };



    const Cards = {
        UnknownPanic: new CardType("Panic", -2, "", "", "/panic.jpg", null, null, null, null, true, true),//неизвестная паника
        UnknownAction: new CardType("Event", -1, "", "", "/event.jpg", null, null, null, null, false, true),//неизвестное событие
        Thing: new CardType("Thing", 0, "Нечто", "Вы нечто! эту карту нельзя передать", "/thing.jpg", null, null, null, null),//нечто
        Infect: new CardType("Infect", 1, "Заражение", "Получив эту карту от другого игрока вы становитесь зараженным \nи обязаны держать ее на руке до конца игры", "/infect.png", Algoritms.MayGiveInfect, Algoritms.MayGiveInfectIn, Algoritms.MayDropInfect, null),//заражение
        Suspicion: new CardType("Suspicion", 2, "Подозрение", "Посмотрите одну карту на руке соседнего игрока", "/suspiction.jpg", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.ActionSuspicion, null),//подозрение
        Analysis: new CardType("Analysis", 3, "Анализ", "Посмотрите все карты на руке соседнего игрока", "/analysis.jpg", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.ActionAnalysis, null),//анализ
        BurnFire: new CardType("Burn", 4, "Огнемет", "Соседний игрок выбывает из игры", "/fire.jpg", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.ActionBurnFire, null),//огнемет
        FireResist: new CardType("Defend\nfrom Fire", 5, "Никакого шашлыка", "Отмените эффект карты огнемет, если стали ее целью.\n возьмите 1 карту событие", "/nofire.jpg", Algoritms.SimpleExchange, Algoritms.FireResistance, Algoritms.OnlyDropAction, null),//шашлык
        Temptation: new CardType("Temptation", 6, "Соблазн", "Поменяйтесь одной картой с любым игроком, если он не на карантине.\n Ваш ход заканчивается", "/temptation.jpg", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.ActionTemptation, Algoritms.ActionTemptation2),//соблазн
        Perseverance: new CardType("Perseverance", 7, "Упорство", "Возьмите 3 карты событий, оставтье на руке одну.\n Затем сыграйте или сбросьте одну карту", "/perseverance.jpg", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.Perseverance, Algoritms.Perseverance2),//Упорство
        GetOff: new CardType("Get Off", 8, "Сматывай удочки", "Поменяйтесь местами с любым игроком по вашему выбору если он не на карантине.\n Игнорируйте заколоченные двери", "/udochki.jpg", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.ChangePlace, null),

        ChangeDirection: new CardType("Change\nDirection", 9, "Гляди по сторонам", "Очередность хода передается в другую сторону. \nМеняется порядок ход и направление обмена картами", "/direction.jpg", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.ChangeDirection, null),
        ChangePlace: new CardType("Change place", 10, "Меняемся местами", "Поменяйтесь местами с соседним игроком,\n если он не на карантие и не за заколоченной дверью", "/changeplace.png", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.ChangePlaceNear, null),
        Whiski: new CardType("Whiski", 11, "Виски", "Покажи все на руке карты всем игрокам", "/whiski.png", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.ActionWhiski, null),
        Axe: new CardType("Axe", 12, "Топор", "Сбросте сыгранную на вас или на соседнего игрока карту Карантин \nили выложенную между вами карту Заколоченная дверь", "/axe.jpg", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.Axe, null),

        NoThanks: new CardType("No Thanks", 13, "Нет уж, спасибо", "Откажитесь от обмена картами.\n возьмите 1 карту событие", "/nothanx.jpg", Algoritms.SimpleExchange, Algoritms.NoThanks, Algoritms.OnlyDropAction, null),
        Fear: new CardType("Fear", 14, "Страх", "Откажитесь от обмена картами и посмотрите карту, от которой отказались.\n возьмите 1 карту событие", "/fear.png", Algoritms.SimpleExchange, Algoritms.Fear, Algoritms.OnlyDropAction, null),
        Past: new CardType("Past", 15, "Мимо", "Откажитесь от обмена картами. Вместо вас картами меняется следующий за вами игрок.\n возьмите 1 карту события", "/mimo.jpg", Algoritms.SimpleExchange, Algoritms.Mist, Algoritms.OnlyDropAction, null),
        StayHere: new CardType("i Stay Here", 16, "Мне и здесь неплохо", "Отмените эффект карты меняемся местами или сматывай удочки,\n если стали ее целью. возьмите 1 карту события", "/stay.png", Algoritms.SimpleExchange, Algoritms.StayHere, Algoritms.OnlyDropAction, null),
        Door: new CardType("Door", 17, "Заколоченная дверь", "Положите эту карту между собой и соседним игроком. Между вами не может совершаться никаких действий и обменов", "/door.jpg", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.Door, null),
        Quarantine: new CardType("Quarantine", 18, "Карантин", "Сыграйте эту карту на соседнего игрока, следующие 3 хода игрок не может играть карты событий", "/quarantine.jpg", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.Quarantine, null),

        PanicOldRopes: new CardType("Old Ropes down", 19, "Старые веревки", "Все сыгранные карты карантин сбрасываются", "/oldropes.jpg", null, null, Algoritms.Panic, null, true),
        PanicThreeFour: new CardType("Panic Three Four", 20, "Три четыре", "Все сыгранные карты закалоченная дверь сбрасываются", "/pthreefour.webp", null, null, Algoritms.Panic, null, true),
        PanicUPS: new CardType("UPS", 21, "Уупс", "Покажите все свои карты на руке остальным игрокам", "/ups.jpg", null, null, Algoritms.Panic, null, true),
        PanicConfessionTime: new CardType("PanicConfessionTime", 22, "Время признаний", "Начиная с вас и по порядку хода каждый показывает либо не показывает все карты на руке остальным игрокам.\n Время признаний завершается когда кто то из игроков показывает карту заражения", "/priznania.jpg", null, null, Algoritms.Panic, Algoritms.PanicConfessionTime, true),
        PanicBetweenUs: new CardType("PanicBetweenUs", 23, "Только между нами", "Покажите все карты на руке соседнему игроку по вашему выбору", "/betweenus.jpg", null, null, Algoritms.Panic, null, true),
        PanicForgot: new CardType("PanicForgot", 24, "Забывчивость", "Сбросьте три карты с руки и возьмите 3 новые карты из колоды, сбрасывая паники ", "/forgot.jpg", null, null, Algoritms.Panic, Algoritms.PanicOnlyOneCardStayInHand, true),
        PanicFriend: new CardType("", 25, "Давай дружить", "поменяйтесь одной картой с любым игроком если он не на карантине", "/friend.jpeg", null, null, Algoritms.Panic, Algoritms.Friends, true),
        PanicMeet: new CardType("", 26, "Свидание вслепую", "Поменяйте одну карту с руки на верхнюю карту колоды сбрасывая паники.\n Ваш ход заканчивается", "/meet.jpg", null, null, Algoritms.Panic, Algoritms.PanicMeet, true),
        PanicChain: new CardType("", 27, "Цепная реакция", "каждый игрок одновременно с остальными отдает одну карту следующему по порядку хода игроку\n игнорируя все сыгранные карты карантин и заколоченная дверь. вы не можете отказаться от обмена. нечто может заразить другого передав заражение. ваш ход заканчивается", "/chain.jpeg", null, null, Algoritms.Panic, Algoritms.ChainPanic, true),
        PanicOneTwo: new CardType("One two", 28, "Раз два", "Поменяйтесь местами с третим от вас игроком слева или справа (по вашему выбору). Игнорируйте все заколоченные двери.\n Если игрок на карантине, смены мес т не происходит", "/onetwo.jpg", null, null, Algoritms.Panic, Algoritms.PanicOneTwo, true),
        PanicGoAway: new CardType("Go away", 29, "Убирайся прочь", "Поменяйтесь местами с любым игроком если он не на карантине", "/goaway.jpg", null, null, Algoritms.Panic, Algoritms.PanicGoAway, true),
        PanicParty: new CardType("", 30, "Вечеринка", "Все сыгранные карты карантин и заколоченная дверь сбрасываются. Затем начиная с вас и по часовой стрелке все парами меняются местами.\n в случае нечетного числа игроков последний игрок остается на месте", "/party.jpeg", null, null, Algoritms.Panic, null, true),

    };

    function findCardByNum(num) {
        for (i in Cards)
            if (Cards[i].num == num) return Cards[i];
        return Cards.UnknownAction;

    }


    class Card {
        constructor(cardtype, owner, cardplace, props) {
            this.card = cardtype;
            this.owner = owner;
            this.cardplace = cardplace;
            this.props = props;
            this.x = 0;
            this.y = 0;
            for (let i in props) this[i] = props[i];
            if (this.isMove == true) Animator.AddCardmove(this, this.from, this.to);

        }

        Draw(ctx, e) {

            let scrCard = ctx.getCanvasToWindow(CardType.width / 2, CardType.height / 2);
            this.x = scrCard.x;//-CardType.width/2;//this.transform.e;
            this.y = scrCard.y;//-CardType.height/2;//this.transform.f
            if (Animator.IsNotMove(this))
                return this.card.Draw(ctx, e);

        }


    }


    class Player {

        static x1 = -2 * CardType.width;
        static y1 = -20;
        static x2 = 5 * CardType.width;
        static y2 = 250;


        constructor(name, num, isMe, cards, state, Phase, QuarantineCount = 0, Perseverance) {
            this.name = name;
            this.playername = name;
            this.place = num;
            this.isMe = isMe;
            this.cards = [];
            cards.forEach((v) => {
                let cardtype = findCardByNum(v.cardnum);
                let card = new Card(cardtype, this, v.cardplace, v);
                if (v.toPlayer != undefined && v.ShowTo == true) card.ShowOneCard = { playername: v.toPlayer, cardplace: v.cardplace };
                this.cards.push(card);
            });

            this.Infected = false;
            this.Thing = false;
            this.state = state;
            this.QuarantineCount = QuarantineCount;
            this.selected = null;
            this.selectedCard = null;
            this.Phase = Phase;
            this.moveOneCard = false;
            this.move = null;
            this.x = 0;
            this.y = 0;
            this.transform = {};
            this.isNear = false;
            this.cardForExchangeOut = null;
            this.isPlayerSelected = false;
            this.Perseverance = [];
            if (Perseverance != undefined) {
                //p.Perseverance = v.Perseverance;
                for (let j in Perseverance) {
                    let cardtype = findCardByNum(Perseverance[j].cardnum);
                    let card = new Card(cardtype, this, j, Perseverance[j]);
                    this.Perseverance.push(card);
                }
            }

        }

        get isNear_() {

            return game.isNearOpponent(this);
        }

        toString() {

            let quarantine = this.QuarantineCount > 0 ? "(на карантине)" : "";
            return this.playername + ((this.Infected == true && this.Thing == false) ? " (заражен)" : (this.Thing == true ? " (нечто)" : "")) + quarantine;
        }


        get PanicCount() {
            return this.cards.filter(v => v.card.isPanic == true).length;

        }
        get InfectCount() {
            return this.cards.filter(v => v.card == Cards.Infect).length;

        }
        get isCardMovableNow() {

            if (this.Phase == Phases.Nothing) return false;
            if (this.selectedCard == null) return false;
            if (this.Phase == Phases.Action) {
                return this.selectedCard.card.isCardMovableForAction(this);
            }
        }

        get isEndTurnExchange() {
            return (this.Phase == Phases.Exchange && (this.state == States.SelectCard || this.state == States.SelectCardAndPlayerForOutgoingExchange) && this.cards.length < 5);
        }

        get isMyTurnToDefend() {
            return (this.Phase == Phases.Answer && this.state == States.DefendFireSelectCard && this.cards.length < 5);
        }
        get isStartTurnExchangeIn() {
            return (this.Phase == Phases.Answer && this.state == States.IncomeExchange && this.cards.length < 5);
        }

        get isAction() {

            return (this.Phase == Phases.Action);
        }

        get isNowMyTurn() {
            return this.Phase == Phases.Action || this.Phase == Phases.SecondAction;
        }

        get isINeedGetCard() {

            return this.Phase == Phases.Action && this.state == States.SelectCard && this.cards.length < 5;
        }


        findCardByPlace(place) {
            let c = this.cards.filter((v) => v.cardplace == place);
            if (c.length > 0) return c[0];
            return undefined;

        }

        Draw(ctx, e, actions) {
            let selectNearPlayersCards = false;
            let actionOnSelectSecondCard = undefined;
            let selectPlayer = false;
            let OnSelectPlayer = undefined;
            let HiLightRLPlayers = false;
            actions.forEach((v) => {
                if (v.selectNearPlayersCards != undefined) selectNearPlayersCards = v.selectNearPlayersCards;
                if (v.actionOnSelectSecondCard != undefined) actionOnSelectSecondCard = v.actionOnSelectSecondCard;
                if (v.selectPlayer != undefined) selectPlayer = v.selectPlayer;
                if (v.OnSelectPlayer != undefined) OnSelectPlayer = v.OnSelectPlayer;
                if (v.HiLightRLPlayers != undefined) HiLightRLPlayers = v.HiLightRLPlayers;
            });

            let errortext = '';
            let scr = ctx.getCanvasToWindow(0, 0);
            this.transform = ctx.getTransform();
            this.x = scr.x;//this.transform.e;
            this.y = scr.y;//this.transform.f

            let lm = (this.cards.length - 1) / 2;



            if (selectPlayer == true || game.me.state == States.SelectCardAndPlayerForOutgoingExchange) {
                if (e != undefined && e.type != 'mousemove') {

                    let p = ctx.getWindowToCanvas(e);
                    if (p != undefined)
                        if (p.x > Player.x1 && p.x < Player.x2 && p.y > Player.y1 && p.y < Player.y2) errortext = this.OnPlayerSelect(OnSelectPlayer, HiLightRLPlayers);
                }
            }

            if (e != undefined && !this.moveOneCard && !selectNearPlayersCards && !selectPlayer && e.type != 'mousemove') {

                //if (this.isMe)
                this.selected = null; this.selectedCard = null; this.move = null;//reset old selection
                //else { this.selected = null; this.selectedCard = null; }

            }

            this.Perseverance.forEach((v, z) => {
                let i = z - lm;
                let h = -150;
                let mx = -50;
                ctx.save();

                ctx.strokeStyle = "#af2";

                ctx.translate(i * 111 - mx, h);
                ctx.rotate(i / 50 * Math.PI);
                if (v.Draw(ctx, e)) this.OnPerseverenceCardSelect(v, z);
                ctx.restore();
            });


            //this.Perseverance
            this.cards.forEach((v, z) => {
                let i = z - lm;
                let h = 35;
                let mx = 0;
                ctx.save();

                ctx.strokeStyle = "#af2";
                //if (this.isMe)
                if (this.selected == z || v.ShowTo == true) { h = -5; ctx.scale(1.2, 1.2); mx = 10; ctx.strokeStyle = "#a00"; }
                ctx.translate(i * 111 - mx, h);

                if (e != undefined) {
                    let c = ctx.getWindowToCanvas(e);
                    if (this.moveOneCard && this.selected == z && this.isMe) {
                        this.move = { x: c.x - 20, y: c.y - 20 };
                        c.x = 1;
                        c.y = 1;

                    }


                }

                if (this.isMe && this.selected == z && this.move != null && this.moveOneCard) {
                    ctx.translate(this.move.x, this.move.y);
                } else ctx.rotate(i / 50 * Math.PI);


                if (v.Draw(ctx, e)) errortext = this.OnCardSelect(v, z, actionOnSelectSecondCard, selectNearPlayersCards);


                ctx.strokeStyle = "#af2";

                ctx.restore();
            });




            ctx.strokeStyle = "#005";
            ctx.font = 'bold 48px serif';
            ctx.fillText(this, 20, 20);
            ctx.strokeText(this, 20, 20);
            ctx.stroke();

            if (errortext != '') TextLabels.ErrorLabelText(errortext);



        }



        OnPlayerSelect(callback, isNearOnly) {
            if (this.isMe) return 'Выбери другого игрока';
            if (!this.isNear && isNearOnly == true) return 'Выбери ближайшего игрока';
            game.opponent = this;  //'это нужно если сейчас действует карта соблазн'
            game.selectedOpponent = this; // это нужно чтобы сработало "выделение" игрока
            this.isPlayerSelected = true; //видимо так надо будет переделать выделение в будущем , но тогда могут быть выделены несколько игроков, така что это спорная строчка
            if (this.selectedCard != null) this.selectedCard.card.RemoveOldAddNewButtons(this, this.selectedCard); //чтобы кнопки действий возникали 
            if (callback != undefined) callback(this);


        }

        OnPerseverenceCardSelect(v, z) {

            selectPerseverance(v);

        }

        OnCardSelect(v, z, actionOnSelectSecondCard, selectNearPlayersCards) {


            if (game.me.isMyTurnToDefend && !this.isMe) return 'Выбери никакого шашлыка';
            if (game.me.isMyTurnToDefend && this.isMe) {


            }

            if (game.me.isStartTurnExchangeIn && !this.isMe) return 'Выбери свою карту для обмена в ответ';
            if (game.me.isStartTurnExchangeIn && this.isMe) {
                let isInExchange = undefined;
                let c = v.card.GetAnswerArray(this, game.opponent);

                c.forEach((i) => {
                    if (i.isInExchange != undefined) isInExchange = i.isInExchange;
                });

                if (isInExchange == undefined || isInExchange == false) return 'Выбери другую карту для обмена в ответ';
            }

            if (game.me.isEndTurnExchange && !this.isMe) return 'Выбери свою карту для обмена';
            if (game.me.isEndTurnExchange && this.isMe) {
                let isOutExchange = undefined;
                let c = v.card.GetExchangeArray(this, game.opponent);

                c.forEach((i) => {
                    if (i.isOutExchange != undefined) isOutExchange = i.isOutExchange;
                });
                if (isOutExchange == undefined || isOutExchange == false) return 'Выбери другую карту для обмена';
                //outChangeAction(v);

            }



            if (this.PanicCount > 0 && !v.card.isPanic) return 'Выбери панику';

            if (selectNearPlayersCards && !this.isMe) {
                if (this.isNear) {
                    this.selected = z; this.selectedCard = v;
                    if (actionOnSelectSecondCard != undefined) actionOnSelectSecondCard(this.playername, v);
                    return '';
                }
                return 'Выбери карту ближайшего игрока';
            }

            this.selected = z; this.selectedCard = v; v.card.RemoveOldAddNewButtons(this, v)
            return '';
        }


    };



    class Game {


        constructor(guid) {

            this.arrow = new Image();
            this.arrow.src = "/arrow.png";
            this.guid = guid;
            this.currentPlayer = null;
            //            this.players =
            this.isStarted = false;
            this.players = [new Player("Игра Нечто", 0, true, [], States.SelectCard, Phases.Action, 0)];
            this.selectedOtherCardPlace = null;
            this.me = this.players[0];
            this.Deck = new Deck(Cards.UnknownAction, 4, 2);
            this.moveOneCard = false;
            this.gameDirection = Direction.CW;
            this.selectedOpponent = null;
            //this.selectedCard = null
            this.opponent = null;
            this.nextplayer = null;
            this.exchange = [];
            this.ViewlineTo = null;
            this.ShowOneCard = null;
            this.gamelog = [];
            this.width = 0;
            this.height = 0;
            this.doors = new Map();
            //events
            this.gameEnded = false;
            this.isBurn = false;
            this.shader = null;


            this.shader = null;//new Shadertoy(document.getElementById("shaderStart").innerText);
            //this.isBurn = true;

        }

        get isSecondAction() {
            this.Deck.table.length > 0;

        }

        findPlayerByNum(num) {
            for (var p of this.players) if (p.place == num) return p;
            return null;
        }

        parseGamelog(message) {
            let result = "";
            this.gamelog = message.gamelog;
            this.gamelog.forEach((v) => { result = result + v + "\r" });

            let q = document.getElementById("gamelog");
            q.value = result;
            q.scrollTop = q.scrollHeight;

        }

        parseYouBurned(message) {

            //youburned
            //this.isStarted = false;

            new TextLabels(message.text, message.text, 100, this.height / 3, "red", 5, 0);
            //this.gameEnded = true;
            //nimator.EndGame();
            this.shader = new Shadertoy("shaders/fire.glsl");
            this.isBurn = true;
        }

        parseGameEnd(message) {
            this.isStarted = false;

            new TextLabels(message.text, message.text, 100, this.height / 2, "red", 5, 0);
            this.gameEnded = true;
            //nimator.EndGame();
        }

        parseChat(message) {
            let result = "";

            message.chat.forEach((v) => { result = result + v.player + ":" + v.message + "\r" });

            let q = document.getElementById("chat");
            q.value = result;
            q.scrollTop = q.scrollHeight;

        }


        parsePlayerList(message) {
            let j = 0;
            let selected = this.me.selected;
            //if (this.me.selected!=null) return;//заглушка чтобы карты не сбрасывались с мышки когда поступает пакет от сервера

            this.ShowOneCard = null;
            this.exchange = [];
            this.players = [];
            message.playerlist.forEach((v, i) => {
                if (v.isDead == true) return;

                let p = new Player(v.playername, v.num, i == 0, v.cards, findStateByNum(v.state), findPhaseByNum(v.phase), v.quarantineCount, v.Perseverance);

                p.Thing = v.thing;
                p.Infected = v.Infected;
                this.players.push(p);

                //if (p.state == States.SelectCardForChain) p.isEndTurnExchange = true;//чтобы сработали правильные проверки и подсказки при выборе карт 

                if (v.num == message.opponent) this.opponent = p;
                if (v.exchange == null) return;
                this.exchange.push({ currentplayer: p, nextplayer: v.exchange.nextplayer, card: findCardByNum(v.exchange.card) });

            });

            this.me = this.players[0];///
            this.nextplayer = message.nextplayer;
            this.me.opponent = this.opponent;
            if (message.deck != undefined) {
                let deck = message.deck;
                this.Deck = new Deck(deck.card, deck.deckCount, deck.dropCount, deck.drop, deck.table, deck);




                this.isStarted = true;
                this.currentPlayer = deck.currentPlayer;
                this.doors = new Map();
                if (deck.doors != undefined) deck.doors.forEach(v => { this.doors.set(v, true) });

            }


            this.players.forEach((v) => { v.isNear = this.isNearOpponent(v) })

        }







        isNearOpponent(player) {
            let pldist = Math.abs(player.place - this.me.place);
            return pldist == 1 || pldist == this.players.length - 1;
        }

        DrawPlayersCards(ctx, e, v, HiLightRLPlayers, HLOpponent, i, actions, HLAllNonQuarantine, isDoorbefore = false, HLThridPlayers) {
            let sy = game.width * 0.25;//.height / 4;//260;
            let sx = game.height * 0.25;//260;
            //if (v == this.me) v.moveOneCard = this.moveOneCard;//отключил перемещение карт мышкой
            if (v != this.me) {
                sx = game.height * 0.7;//750;
                sy = game.width * 0.5;
            }
            let ang = 2 * Math.PI * (i / (this.players.length + this.players.length / 5));// + 2.5));
            if (v != this.me) ang += 0.5;
            let x = Math.cos(ang) * sx;
            let y = - Math.sin(ang) * sy;
            //v.x = x;
            //v.y = y;
            ctx.save();

            if (v != this.me) ctx.scale(0.5, 0.5); // else x = this.height - Card.height;

            ctx.translate(y, x);

            ctx.rotate(ang);



            if (this.selectedOpponent == v) {
                ctx.scale(1.2, 1.2);
                ctx.fillStyle = "#503";
                ctx.strokeStyle = "#a52";
                ctx.roundRect(Player.x1 - 10, Player.y1 - 10, Player.x2 + 20, Player.y2 + 20, 20).stroke();
            }

            if (this.isNearOpponent(v) && HiLightRLPlayers == true && v != this.me
                || (HLOpponent && v.place == this.nextplayer)
                || (HLAllNonQuarantine == true && v.QuarantineCount == 0 && v != this.me)
                || (HLThridPlayers == true && v.QuarantineCount == 0 && v != this.me && Math.abs(this.me.place - v.place) == 3)
                || (v.state == States.IncomeExchange)


            ) {
                ctx.fillStyle = "#003";
                ctx.strokeStyle = "#a02";
                ctx.roundRect(Player.x1, Player.y1, Player.x2, Player.y2, 20).stroke();
            }

            v.Draw(ctx, e, actions);
            if (this.currentPlayer == v.place) ctx.drawImage(this.arrow, -30, -150, 100, 100);
            //if (this.currentPlayer == v.place) ctx.drawImage(this.arrow, -30, -150, 100, 100);

            ctx.save();
            ctx.translate(CardType.width * 3, -100);
            ctx.rotate(-1);
            ctx.scale(0.5, 0.5);

            if (isDoorbefore == true)
                Cards.Door.Draw(ctx, e);
            ctx.restore();

            ctx.restore();

        }



        drawStatePhase() {

            let stateText = "";
            if (this.opponent != null) stateText = "сейчас ходит " + this.opponent;
            let phaseText = "";
            switch (this.me.state) {
                case States.PanicForgot:
                    stateText = "Выбери карту";
                    phaseText = "которая останется на руке";
                    break;
                case States.SelectCardForChain:
                    stateText = "Выбери свою карту";
                    phaseText = "для передачи следующему";
                    break;

                case States.SelectCardAndPlayerForOutgoingExchange:
                    stateText = "Выбери свою карту и игрока с кем обменяться";

                    break;


                case States.IncomeExchange:
                    stateText = "Выбери свою карту \nдля обмена или отказа";

                    break;
                case States.SelectCard:
                    stateText = "Выбери свою карту";
                    switch (this.me.Phase) {
                        case Phases.Exchange:
                            phaseText = "для обмена";
                            break;
                        case Phases.Action:
                            phaseText = "для действия";
                            break;
                        case Phases.Answer:
                            phaseText = "для ответа";
                            break;

                    }


                    break;

            }
            if (this.isStarted == false) {
                stateText = "Войдите";
                phaseText = "и дождавшись остальных играков нажмите (Начать игру)";
            }

            new TextLabels("state", stateText + '\n' + phaseText, game.width / 2 - 200, game.height / 2 + 55, "#000", 2, 0);
            //new TextLabels("phase", phaseText, game.width/2-150, game.height/2+44, "#000", 2, 0);


        }

        Draw(ctx, e, w, h) {


            if (this.gameEnded == true) if (Math.random() > 0.7) Animator.EndGame();



            this.width = w;
            this.height = h;
            ctx.clearRect(0, 0, w, h);



            ctx.save();

            ctx.save();
            //ctx.translate(-10, -200);
            TextLabels.DrawAll(ctx, e);
            if (e != undefined) TextLabels.Delete("Hint");

            ctx.restore();



            ctx.translate(w / 2, h / 2); //центр экрана это (0,0)

            if (this.me.selectedCard == null || this.me.Phase == Phases.Nothing) Button.DeleteAll();

            if (this.me.selectedCard != null) if (this.me.selectedCard.card.Description != undefined) {
                //.getAttribute('data-tooltip');
                new TextLabels("description", this.me.selectedCard.card.Description, 0, game.height - 122, "#000", 1.8, 0);
                //this.drawText(ctx, -this.width / 2, this.height / 2 - 100, this.me.selectedCard.card.Description);
                //canvas.setAttribute('data-tooltip',this.me.selectedCard.card.Description);
                if (e != undefined)
                    //x = event.x - this.offsetLeft;
                    //y = event.y - this.offsetTop;
                    ctx.drawPoint(e.x, e.y, 5, 'red', [this.me.selectedCard.card.Description]);
            }

            this.drawStatePhase();

            let HLOpponent = false;
            let HiLightRLPlayers = false;
            let HLAllNonQuarantine = false;
            let HLThridPlayers = false;
            let HiLightText = "";
            let c = [];
            let card = null;
            switch (this.me.Phase) {
                case Phases.Exchange:
                    HLOpponent = this.nextplayer != null;
                    break;
                case Phases.Action:

                    if (this.me.selectedCard != null) card = this.me.selectedCard.card;
                    if (card == null) break;
                    if (this.me.isNowMyTurn) {
                        c = card.GetActionArray(this.me);
                        c.forEach((v) => {
                            if (v.HiLightText != undefined) HiLightText = v.HiLightText;

                            // this.drawText(ctx, -10, 20, v.HiLightText);
                            if (v.HiLightRLPlayers == true) HiLightRLPlayers = true;
                            if (v.HLAllNonQuarantine == true) HLAllNonQuarantine = true;
                        });

                    }


                    break;
                case Phases.SecondAction:
                    this.Deck.table.forEach((v) => card = v.card);
                    if (card == null) break;


                    if (this.me.isNowMyTurn && this.me.selectedCard == null) {
                        c = card.GetSecondActionArray(this.me, card);
                        c.forEach((v) => {
                            if (v.HiLightText != undefined) HiLightText = v.HiLightText;//this.drawText(ctx, -10, 20, v.HiLightText);
                            if (v.HiLightRLPlayers == true) HiLightRLPlayers = true;
                            if (v.HLAllNonQuarantine == true) HLAllNonQuarantine = true;
                            if (v.HLThridPlayers == true) HLThridPlayers = true;
                        });

                    }


                    break;

                case Phases.Answer:
                    if (this.me.state == States.DefendPlaceChange) {




                    }
                    break;


            }
            new TextLabels("HiLightText", HiLightText, game.width / 2 + 200, game.height / 2 + 33, "#000", 1.5, 0);

            let central = this.me.place;

            this.players.sort((a, b) => a.place - b.place).forEach((v, i) => {
                let k = v.place;
                if (k == this.players.length) k = 0;
                let door = this.doors.get(k)
                let newplace = v.place - central;
                if (newplace < 0) newplace = newplace + this.players.length;
                this.DrawPlayersCards(ctx, e, v, HiLightRLPlayers, HLOpponent, newplace, c, HLAllNonQuarantine, door, HLThridPlayers);
            });





            ctx.save();
            ctx.translate(-100, -200);
            Button.DrawAll(ctx, e);
            ctx.restore();

            ctx.save();
            ctx.translate(-20, -200);
            this.Deck.Draw(ctx, e);
            ctx.restore();
            /*
                        ctx.save();
                        ctx.translate(-10, -200);
                        TextLabels.DrawAll(ctx, e);
                        ctx.restore();
            */
            ctx.restore();
            ctx.save();
            Animator.DrawAll(ctx, this);
            ctx.restore();

            if (this.shader != null) ctx.drawImage(this.shader.Draw(e, 300, 300), 0, 0, w, h);
        }

    };




    function findPhaseByNum(num) {
        for (i in Phases)
            if (Phases[i] == num) return Phases[i];
        return Phases.Nothing;

    }

    function findStateByNum(num) {
        for (i in States)
            if (States[i] == num) return States[i];
        return States.Nothing;

    }

    //----------------------------------------------------------------
    const Phases = {
        Nothing: 0,
        Exchange: 1,
        Action: 2,
        Answer: 3,
        SecondAction: 4

    };

    const Direction = {
        CW: 0,
        CCW: 1
    };

    const States = {
        Nothing: 0,
        SelectCard: 2,
        OutgoingExchange: 3,
        IncomeExchange: 4,
        PerseveranceSelectCard: 5,
        SelectPlayer: 6,
        DefendFireSelectCard: 7,
        Panic: 8,
        SelectCardAndPlayerForOutgoingExchange: 9,
        SelectCardForChain: 10,
        PanicConfessionTime: 11,
        PanicForgot: 12,
        PanicMeet: 13,
        PanicOneTwo: 14,
        DefendPlaceChange: 15,
    };



    //---------------------------------------------------------
    var wsUrl = location.origin.replace(/^http/, 'ws')
    let websocket = null;//new WebSocket(wsUrl);

    function startWS() {
        websocket = new WebSocket(wsUrl);

        websocket.mysend = function (message) {

            if (websocket.OPEN == websocket.readyState) {
                websocket.send(message); return;
            }

            window.setTimeout(() => {
                websocket.mysend(message);
            }, 1000);

        }

        websocket.senddata = function (data) {
            let message = JSON.stringify(data).toString();
            websocket.mysend(message);
            console.log(data);
        }



        websocket.onopen = (evt) => { console.log(evt) };
        websocket.onclose = function (evt) {
            //console.log(evt);
            document.getElementById("loginbutton").hidden = false;
            document.getElementById("room").hidden = false;
            document.getElementById("login").hidden = false;
            document.getElementById("startgamebutton").hidden = true;
            console.error(evt.reason);
            TextLabels.ErrorLabelText(evt.reason);

            if (evt.code == '1006' || evt.code == '1001') { startWS(); start(); sendLogin(); return };
            window.update();
            startWS();

        };
        websocket.onerror = function (evt) { console.log(evt) };

        websocket.onmessage = function (evt) {


            let message = JSON.parse(evt.data);
            switch (message.messagetype) {
                case 'playerguid':
                    game = new Game(message.guid);
                    document.cookie = evt.data;
                    document.getElementById("loginbutton").hidden = true;
                    document.getElementById("room").hidden = true;
                    document.getElementById("login").hidden = true;
                    document.getElementById("startgamebutton").hidden = false;

                    break;
                case 'playerlist':
                    game.parsePlayerList(message);
                    document.getElementById("logindiv").hidden = game.isStarted;
                    console.log(evt.data);
                    //game.shader = null;
                    break;
                case 'gamelog':
                    game.parseGamelog(message);
                    break;
                case 'chat':
                    game.parseChat(message);
                    break;
                case 'gameend':
                    game.parseGameEnd(message);
                    break;
                case 'youburned':
                    game.parseYouBurned(message);
                    break;


            }

        };
        autoping();

    }




    var RAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
        callback();
        window.setTimeout(callback, 200);
    };


    let game = new Game(123);
    game.shader = new Shadertoy("shaders/start.glsl");


    window.addEventListener("mousemove", function (event) {
        if (game == null) return;
        // if (game.moveOneCard)
        render(event);
    });

    window.addEventListener("mousedown", function (event) {
        if (game == null) return;
        render(event);
        // if (game.me.selected != null) game.moveOneCard = game.me.isCardMovableNow;

    });

    window.addEventListener("mouseup", function (e) {
        if (game == null) return;
        game.moveOneCard = false;
    });

    function ChangePlaceNear(player) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "ChangePlaceNear";
        p.bymycardplace = game.me.selectedCard.cardplace;
        p.otherPlayerName = player.name;
        websocket.senddata(p);

    }



    function ChangePlace(player) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "ChangePlace";
        p.bymycardplace = game.me.selectedCard.cardplace;
        p.otherPlayerName = player.name;
        websocket.senddata(p);

    }


    function Analysis(player) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "Analysis";
        p.place = game.me.selectedCard.cardplace;
        p.otherPlayerName = player.name;
        websocket.senddata(p);

    }

    function BurnPlayer(player) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "BurnPlayer";
        p.bymycardplace = game.me.selectedCard.cardplace;
        p.otherPlayerName = player.name;
        websocket.senddata(p);

    }

    function Axe(player) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "Axe";
        p.bymycardplace = game.me.selectedCard.cardplace;
        p.otherPlayerName = player.name;
        websocket.senddata(p);

    }

    function SetQuarantine(player) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "Quarantine";
        p.bymycardplace = game.me.selectedCard.cardplace;
        p.otherPlayerName = player.name;
        websocket.senddata(p);

    }


    function SetDoor(player) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "Door";
        p.bymycardplace = game.me.selectedCard.cardplace;
        p.otherPlayerName = player.name;
        websocket.senddata(p);

    }


    function selectPerseverance(pl) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "SelectPerseverance";

        p.place = pl.cardplace;

        websocket.senddata(p);

    }

    function usePerseverance(pl) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "StartPerseverance";

        p.bymycardplace = pl.cardplace;

        websocket.senddata(p);

    }

    function useTemptation(pl) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "StartTemptation";

        p.bymycardplace = pl.cardplace;

        websocket.senddata(p);

    }

    function AcceptChangePlace(pl) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "AcceptChangePlace";

        //p.bymycardplace = pl.cardplace;

        websocket.senddata(p);

    }

    function DefendFromChangePlace(pl) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "DefendFromChangePlace";

        p.bymycardplace = pl.cardplace;

        websocket.senddata(p);

    }

    function DefendFromFire(pl) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "DefendFromFire";

        p.bymycardplace = pl.cardplace;

        websocket.senddata(p);

    }

    function Panic(pl) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "Panic";
        p.place = pl.cardplace;//
        //console.log(place);
        websocket.senddata(p);

    }

    function ChangeDirection(pl) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "ChangeDirection";
        p.place = pl.cardplace;//
        //console.log(place);
        websocket.senddata(p);
    }

    function showAllCards(place) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "ShowAllCards";
        p.place = place.cardplace;//
        //console.log(place);
        websocket.senddata(p);

    }

    function ShowAllCardsToPlayer(pl) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "ShowAllCards";
        p.place = pl.cardplace;//
        //console.log(place);
        websocket.senddata(p);
    }

    function dropcard(place) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "DropCard";
        p.place = place.cardplace;//
        console.log(place);
        websocket.senddata(p);

    }

    function ShowMeCard(otherplayername, place) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "ShowMeCard";
        p.place = place.cardplace;//
        p.bymycardplace = game.me.selectedCard.cardplace;
        p.otherPlayerName = otherplayername;
        //console.log(p);
        websocket.senddata(p);
        // game.me.selected = null;

    }

    function exchangecard(place) {
        if (States.IncomeExchange == game.me.state) return exchangecardin(place);
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "outExchangeCard";
        p.place = place.cardplace;
        p.opponent = game.opponent.playername;
        websocket.senddata(p);
    }

    function exchangecardin(place) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "inExchangeCard";
        p.place = place.cardplace;
        p.opponent = game.opponent.playername;
        websocket.senddata(p);
    }

    function nothanks(pl) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "NoThanks";
        p.place = pl.cardplace;
        p.opponent = game.opponent.playername;
        websocket.senddata(p);
    }

    function fear(pl) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "Fear";
        p.place = pl.cardplace;
        p.opponent = game.opponent.playername;
        websocket.senddata(p);
    }

    function mist(pl) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "Mist";
        p.place = pl.cardplace;
        p.opponent = game.opponent.playername;
        websocket.senddata(p);
    }

    function PanicOneTwo(player) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "PanicOneTwo";
        //p.bymycardplace = game.me.selectedCard.cardplace;
        p.otherPlayerName = player.name;
        websocket.senddata(p);

    }


    function PanicNoConfessionTime(pl) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "PanicNoConfessionTime";
        p.place = pl.cardplace;
        websocket.senddata(p);


    }

    function PanicConfessionTime(pl) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "PanicConfessionTime";
        p.place = pl.cardplace;
        websocket.senddata(p);


    }

    function PanicStopConfessionTime(pl) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "PanicStopConfessionTime";
        p.place = pl.cardplace;
        websocket.senddata(p);


    }

    function PanicGoAway(pl) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "PanicGoAway";
        p.place = pl.cardplace;
        p.opponent = game.opponent.playername;
        websocket.senddata(p);
    }

    function PanicForgot(pl) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "PanicForgot";
        p.place = pl.cardplace;
        websocket.senddata(p);

    }

    function PanicMeet(pl) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "PanicMeet";
        p.place = pl.cardplace;
        websocket.senddata(p);

    }


    function start() {
        let loginelement = document.getElementById("login");
        let roomElement = document.getElementById("room");
        if (document.cookie != "") {
            try {
                let p = JSON.parse(document.cookie);
                p.messagetype = 'newplayer';
                p.numofPlayers = 1;
                loginelement.value = p.playername;
                roomElement.value = p.roomname;


                return;
            } catch { }
        }

    }





    function update() {

        render();

        RAF(update);
    }



    function render(e) {
        if (game == null) return;
        w = canvas.width;
        h = canvas.height;
        game.Draw(ctx, e, w, h);
    }

    function sendQuery() {
        let q = document.getElementById("query").value;
        websocket.senddata({ messagetype: "query", query: q });

    }


    function sendChat() {
        let q = document.getElementById("chatmessage");
        let p = JSON.parse(document.cookie);
        p.messagetype = 'chatmessage';
        if (q.value.trim() == "") return;
        p.message = q.value;

        websocket.senddata(p);
        q.value = "";

    }

    function chat(e) {
        e = window.event;
        if (e.keyCode == 13) {
            sendChat();
        }
    }

    function sendLogin() {
        let loginelement = document.getElementById("login");
        let thing = false;
        try {
            let pre = JSON.parse(document.cookie);
            thing = pre.thing;
        } catch { }
        let p = {
            messagetype: 'newplayer',
            roomname: document.getElementById("room").value,
            password: '1',
            numofPlayers: 1,
            playername: loginelement.value,
            guid: game == null ? '' : game.guid,
            thing: thing

        };

        websocket.senddata(p);
        document.getElementById("startgamebutton").hidden = false;
    }

    function LogoutGame() {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'logoutgame';

        websocket.senddata(p);


    }

    function startGame() {

        try {
            let p = JSON.parse(document.cookie);
            p.messagetype = 'startgame';

            websocket.senddata(p);
            //document.getElementById("logindiv").hidden = true;
            //document.getElementById("startgamebutton").hidden = true;

        } catch { }
    }

    function gameLoop() {

        if (game == null) return;
        if (game.isStarted == false) return;
        let p = JSON.parse(document.cookie);


    }

    // window.onbeforeunload = () => LogoutGame();
    window.addEventListener("close", LogoutGame);
    window.addEventListener("resize", resizeCanvas);

    function resizeCanvas() {
        canvas = document.getElementById("canvas");
        canvas.height = window.innerHeight;
        canvas.width = window.innerWidth;

        ctx = canvas.getContext("2d");
        ctx.globalCompositeOperation = 'destination-over';
        render();


    }

    function autoping() {
        window.setTimeout(() => {
            let ping = JSON.stringify({ messagetype: 'ping' }).toString();
            if (websocket.OPEN == websocket.readyState)
                websocket.send(ping);
            autoping();

        }, 2000);
    }

    startWS();

    start();

    update();

</script>

</html>