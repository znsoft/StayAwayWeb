<html>
<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta charset="UTF-8">
</head>
<title>Stay away</title>

<style>

    * {
        box-sizing: border-box;
    }

    html {
        height: 100%;
    }

    body {
        background-color: #61a0a0;
        height: 100%;
        margin: 0;
        padding: 0;
    }

    canvas {
        display: block;
        width: 100%;
        height: 100%;
        touch-action: none;
    }

    button, select, a, a:visited {
        padding: 8px 12px;
        border: 0px;
        border-radius: 5px;
        margin-right: 5px;
        color: #FFFFFF;
        background-color: #000000;
        font-family: monospace;
        font-size: 11px;
        cursor: pointer;
        text-decoration: none;
        text-transform: uppercase;
    }

        button:hover, select:hover, a:hover {
            background-color: #FFFFFF;
            color: #000000;
        }

    img {
        padding: 4px;
        border: 0px;
        border-radius: 5px;
        margin-right: 5px;
        background-color: #000000;
        vertical-align: middle;
        cursor: pointer;
        image-rendering: pixelated;
    }

        img:hover {
            background-color: #FFFFFF;
        }

    option {
        color: #ffffff;
        background-color: #000000;
    }

    #toolbar {
        transition: opacity 1s;
    }
</style>

<body>

    <div id="logindiv">
        Room:<input id="room" value="1" hidden="true"></input>
        Player:<input id="login"></input>
        <button id="loginbutton" onclick="sendLogin()">Login</button>
        <button id="startgamebutton" hidden="true" onclick="startGame()">Startgame</button>

    </div>

    <textarea id="gamelog" style="opacity: 0.4; position: absolute; transition: opacity 1s;" cols="40" rows="20" onclick="console.log('click')" readonly="true"></textarea>

    <canvas id="canvas" width="2000" height="2000">Please update your browser<br> in order to view this page.</canvas>
    <pre id="chat"></pre>



</body>

<script>




    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
    };

    CanvasRenderingContext2D.prototype.getWindowToCanvas = function (e) {
        if (e == undefined) return;
        //first calculate normal mouse coordinates
        e = e || window.event;
        var target = e.target || e.srcElement,
            style = target.currentStyle || window.getComputedStyle(target, null),
            borderLeftWidth = parseInt(style["borderLeftWidth"], 10),
            borderTopWidth = parseInt(style["borderTopWidth"], 10),
            rect = target.getBoundingClientRect(),
            offsetX = e.clientX - borderLeftWidth - rect.left,
            offsetY = e.clientY - borderTopWidth - rect.top;
        let x = (offsetX * target.width) / target.clientWidth;
        let y = (offsetY * target.height) / target.clientHeight;

        //then adjust coordinates for the context's transformations
        //const ctx = canvas.getContext("2d");
        var transform = this.getTransform();
        const invMat = transform.invertSelf();
        return {
            x: x * invMat.a + y * invMat.c + invMat.e,
            y: x * invMat.b + y * invMat.d + invMat.f
        };
    }

    CanvasRenderingContext2D.prototype.getCanvasToWindow = function (x, y) {

        var invMat = this.getTransform();
        //const invMat = transform.invertSelf();
        return {
            x: x * invMat.a + y * invMat.c + invMat.e,
            y: x * invMat.b + y * invMat.d + invMat.f
        };
    }

    class Button {
        constructor(id, text, x, y, w, h, callback, p) {
            this.id = id;
            this.text = text;
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
            this.callback = callback;
            Button.buttons.set(id, this);
            this.p = p;
            //this.p1 = p1;

        }

        static buttons = new Map();

        static add() {


        }

        static DrawAll(ctx, e) {
            Button.buttons.forEach((v, k) => v.Draw(ctx, e));

        }

        static Delete(id) {
            Button.buttons.delete(id);

        }

        static DeleteAll() {
            Button.buttons.clear();
        }

        Draw(ctx, e) {
            ctx.save();
            ctx.translate(this.x, this.y);

            ctx.fillStyle = "#000";
            ctx.font = '16px serif';
            ctx.fillText(this.text, 3, 16);
            ctx.roundRect(0, 0, this.w, this.h, 5).stroke();
            if (e != undefined) {
                let c = ctx.getWindowToCanvas(e);

                if (c != undefined)
                    if (c.x > 0 && c.x < this.w && c.y > 0 && c.y < this.h && this.callback != undefined) { this.callback(this.p); game.me.selected = null; game.moveOneCard = false;}
            }
            ctx.restore();

        }

    }

    class Deck {
        constructor(upCard, cardsLeft, dropCount, drop=[], table=[]) {
            this.upCard = upCard;
            this.cardsLeft = cardsLeft;
            this.Doors = [];
            this.Drop = dropCount;
            
            this.drop = drop.reverse().map(v => findCardByNum(v));
            this.table = table==undefined?[]:table.map((v) => findCardByNum(v));
        }

        Draw(ctx, e) {




            ctx.save();
            // ctx.globalCompositeOperation = 'destination-over';
            ctx.translate(this.cardsLeft * 2, this.cardsLeft * 2);
            ctx.rotate(Math.PI / 2);
            this.upCard.Draw(ctx);
            ctx.restore();

            for (let i = this.cardsLeft; i > 1; i--) {

                ctx.save();
                ctx.translate(i * 2, i * 2);
                ctx.rotate(Math.PI / 2);
                Cards.UnknownAction.Draw(ctx);
                ctx.restore();
            }


            ctx.save();
            // ctx.globalCompositeOperation = 'destination-over';
            ctx.translate(0, 100);
            //ctx.rotate(Math.PI / 2);

            this.table.forEach((v, i) => {

                ctx.save();
                ctx.translate(i * 102, i * 2);
                //ctx.rotate(Math.PI / 2);
                v.Draw(ctx);
                ctx.restore();

            });


            ctx.restore();


            ctx.save();
            // ctx.globalCompositeOperation = 'destination-over';
            ctx.translate(200, -50);


            this.drop.forEach((v, i) => {

                ctx.save();
                ctx.translate(i * 1, i * 1 + 40);
                ctx.rotate(Math.PI / 1.5 + i / 120);
                v.Draw(ctx);
                ctx.restore();


            });


            ctx.rotate(Math.PI / 2.5);
            ctx.fillStyle = "#000";
            ctx.font = '16px serif';
            ctx.fillText("Drop", 10, 20);
            ctx.roundRect(0, 0, 95, 150, 10).stroke();
            //if (this.Drop == 0)Cards.UnknownAction.Draw(ctx);

            ctx.restore();




        }

    };






    class Card {
        static width= 95;
        static height= 150;
        static splace = 0;
        constructor(name, num, CardCaption, Description, img, Exchange, Answer, Action, Defend, isPanic = false, isUnknown = false) {
            this.name = name;
            this.num = num;
            this.isPanic = isPanic;
            this.isUnknown = isUnknown;
            this.CardCaption = CardCaption;
            this.Description = Description;
            this.img = img;
            this.Exchange = Exchange;
            this.Answer = Answer;
            this.Action = Action;
            this.Defend = Defend;
            Card.splace++;
            this.place = Card.splace;
            this.opponent = null;
            this.x = 0;
            this.y = 0;
        }

        GetActionArray(player) {
            if (this.Action == null) return [];
            let check = null;
            if (Array.isArray(this.Action)) check = this.Action; else check = [this.Action];
            if (typeof (this.Action) == "function") check = this.Action(player);
            if (check == null || check == undefined) return [];
            if (!Array.isArray(check)) check = [check];
            return check;

        }

        GetExchangeArray(player, other) {
            if (this.Exchange == null) return [];
            let check = null;
            if (Array.isArray(this.Exchange)) check = this.Exchange; else check = [this.Exchange];
            if (typeof (this.Exchange) == "function") check = this.Exchange(player, other);
            if (check == null || check == undefined) return [];
            if (!Array.isArray(check)) check = [check];
            return check;

        }

        GetAnswerArray(player, other) {
            if (this.Answer == null) return [];
            let check = null;
            if (Array.isArray(this.Answer)) check = this.Answer; else check = [this.Answer];
            if (typeof (this.Answer) == "function") check = this.Answer(player, other);
            if (check == null || check == undefined) return [];
            if (!Array.isArray(check)) check = [check];
            return check;

        }


        isCardMovableForAction(player) {
            let c = this.GetActionArray(player);
            //Actions.Drop.
            return c.filter((v) => v.MayMove == true).length > 0;
            //v.hasOwnProperty("MayMove") &&
            //for (var c of check) { }

        }

        RemoveOldAddNewButtons(player, z) {
            Button.DeleteAll();
            //  if (!(player.State == States.IncomeExchange || player.State == States.SelectCard || player.State == States.SelectPlayer || player.State == States.PerseveranceSelectCard || player.State == States.SuspicionSelectCard)) return;
            if (player.Phase == Phases.Nothing) return;
            let c = [];
            if (player.Phase == Phases.Action)
                c = this.GetActionArray(player);
            if (player.Phase == Phases.Exchange)
                c = this.GetExchangeArray(player, this.opponent);
            if (player.Phase == Phases.Answer)
                c = this.GetAnswerArray(player, this.opponent);
            let x = 220;
            let y = 250;
            c.forEach((v) => {
                if (v.hasOwnProperty("Button")) {
                    new Button(v.Button.Text, v.Button.Text, x, y, v.Button.Text.length * 10, 20, v.Button.action, z);
                    x += v.Button.Text.length * 10 + 5;
                }
            });

        }

        Draw(ctx) {

            //ctx.beginPath();
            if (this.isPanic && !this.isUnknown) ctx.scale(2.0, 2.0);
            ctx.fillStyle = "#000";
            ctx.font = '16px serif';
            ctx.fillText(this.name, 10, 20);
            ctx.font = '16px serif';
            let y = 30;
            for (var s of this.CardCaption.split("\n")) ctx.fillText(s, 1, y += 12);

            ctx.roundRect(0, 0, Card.width, Card.height, 10);
            ctx.fillStyle = this.isUnknown ? "#b92" : "#f5fb";
            ctx.fill();

            ctx.stroke(); // Draw it
            //ctx.closePath();
        }


    };



    const Actions = {
        Nothing: { id: - 1, },
        Drop: { id: 0, Button: { Text: "Drop", action: dropcard }, },
        outChange: { id: 1, Button: { Text: "Exchange", action: exchangecard }, isOutExchange: true },// OnSelectAction: exchangecard },
        inChange: { id: 1, Button: { Text: "Exchange", action: exchangecardin }, isInExchange: true },// OnSelectAction: exchangecard },
        SawOneCard: { id: 2, HiLightText: "Select card of a player", MayMove: true, HiLightRLPlayers: true, selectNearPlayersCards: true, actionOnSelectSecondCard: ShowMeCard },
        SawAllCards: { id: 3, HiLightText: "Select player", MayMove: true, HiLightRLPlayers: true , selectPlayer:true},
        RejectExchange: { id: 4, Button: { Text: "Reject",action:rejectExchange }, },
        Burn: { id: 5, HiLightText: "Select player", MayMove: true, HiLightRLPlayers: true, selectPlayer: true, OnSelectPlayer :BurnPlayer},
        DefendFromFire: { id: 6, Button: { Text: "Defend", action: DefendFromFire } },
        exChange: { id: 7, Button: { Text: "Exchange", action: exchangecardin } },
        ShowAllCards: { id: 8, HiLightText: "Show all cards",Button: { Text: "Use", action: showAllCards}, },


    };

    const Algoritms = {
        MayGiveInfect: function (me, other) {
            if (me.Thing == true) return Actions.outChange;
            if (me.Infected == true && other.Thing == true && me.InfectCount() > 1) return Actions.outChange;
            return Actions.Nothing;
        },
        MayGiveInfect: function (me, other) {
            if (me.Thing == true) return Actions.inChange;
            if (me.Infected == true && other.Thing == true && me.InfectCount() > 1) return Actions.inChange;
            return Actions.Nothing;
        },
        MayDropInfect: function (me) {
            if (me.Infected == true && me.InfectCount() == 1) return Actions.Nothing;
            return Actions.Drop;
        },
        OnlyDropAction: (me) => Actions.Drop,
        SimpleExchange: (me, other) => Actions.outChange,
        SimpleAnswer: (me, other) => {
            if (me.state == States.IncomeExchange) return Actions.inChange;
            return Actions.Nothing;
        },
        ActionSuspicion: (me) => [Actions.Drop, Actions.SawOneCard],
        ActionAnalysis: (me) => [Actions.Drop, Actions.SawAllCards],
        ActionBurnFire: (me) => [Actions.Drop, Actions.Burn],
        ActionWhiski: (me) => [Actions.Drop, Actions.ShowAllCards],
        FireResistance: (me, other) => {
            if (me.state == States.DefendFireSelectCard) return Actions.DefendFromFire;
            return Actions.inChange;
        }

    };



    const Cards = {
        UnknownPanic: new Card("Panic", -2, "Паника", "", "", null,null, null, null, true, true),//неизвестная паника
        UnknownAction: new Card("Event", -1, "Событие", "", "", null,null, null, null, false, true),//неизвестное событие
        Thing: new Card("Thing", 0, "Нечто", "Вы нечто! эту карту нельзя передать", "", null, null, null,null),//нечто
        Infect: new Card("Infect", 1, "Заражение", "Получив эту карту от другого игрока вы становитесь зараженным и обязаны держать ее на руке до конца игры", "", Algoritms.MayGiveInfect, Algoritms.MayGiveInfectIn, Algoritms.MayDropInfect, null),//заражение
        Suspicion: new Card("Suspicion", 2, "Подозрение", "Посмотрите одну карту на руке соседнего игрока", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.ActionSuspicion, null),//подозрение
        Analysis: new Card("Analysis", 3, "Анализ", "Посмотрите все карты на руке соседнего игрока", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.ActionAnalysis, null),//анализ
        BurnFire: new Card("Burn", 4, "Огнемет", "Соседний игрок выбывает из игры", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer,Algoritms.ActionBurnFire, null),//огнемет
        FireResist: new Card("Defend\nfrom Fire", 5, "Никакого шашлыка", "Отмените эффект карты огнемет, если стали ее целью. возьмите 1 карту событие", "", Algoritms.SimpleExchange, Algoritms.FireResistance, Algoritms.OnlyDropAction, Algoritms.FireResistance),//шашлык
        Temptation: new Card("Temptation", 6, "Соблазн", "Поменяйтесь одной картой с любым игроком, если он не на карантине. Ваш ход заканчивается", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.OnlyDropAction, null),//соблазн
        Perseverance: new Card("Perseverance", 7, "Упорство", "Возьмите 3 карты событий, оставтье на руке одну. Затем сыграйте или сбросьте одну карту", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.OnlyDropAction, null),//Упорство
        GetOff: new Card("Get Off", 8, "Сматывай удочки", "", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.OnlyDropAction, Algoritms.FireResistance),

        ChangeDirection: new Card("Change\nDirection", 9, "Change\nDirection", "", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.OnlyDropAction, null),
        ChangePlace: new Card("Change place", 10, "Меняемся местами", "Поменяйтесь местами с соседним игроком, если он не на карантие и не за заколоченной дверью", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.OnlyDropAction, null),
        Whiski: new Card("Whiski", 11, "Виски", "", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.ActionWhiski, null),
        Axe: new Card("Axe", 12, "Топор", "Сбросте сыгранную на вас или на соседнего игрока карту Карантин или выложенную между вами карту Заколоченная дверь", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.OnlyDropAction, null),

        NoThanks: new Card("No Thanks", 13, "Нет уж, спасибо", "Откажитесь от обмена картами. возьмите 1 карту событие", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.OnlyDropAction, Algoritms.FireResistance),
        Fear: new Card("Fear", 14, "Страх", "Откажитесь от обмена картами и посмотрите карту, от которой отказались. возьмите 1 карту событие", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.OnlyDropAction, Algoritms.FireResistance),
        Past: new Card("Past", 15, "Мимо", "Откажитесь от обмена картами. Вместо вас картами меняется слкдующий за вами игрок. возьмите 1 карту событие", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.OnlyDropAction, Algoritms.FireResistance),
        StayHere: new Card("i Stay Here", 16, "i Stay Here", "", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.OnlyDropAction, Algoritms.FireResistance),
        Door: new Card("Door", 17, "Заколоченная дверь", "Положите эту карту между собой и соседним игроком. Между вами не может совершаться никаких действий и обменов", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.OnlyDropAction, null),
        Quarantine: new Card("Quarantine", 18, "Карантин", "", "", Algoritms.SimpleExchange, Algoritms.SimpleAnswer, Algoritms.OnlyDropAction, Algoritms.FireResistance),

        PanicOldRopes: new Card("Old Ropes down", 19, "Old Ropes", "", "", null, null,null, null, true),
        PanicThreeFour: new Card("Panic Three Four", 20, "Three Four", "", "", null, null, null, null, true),
        PanicUPS: new Card("UPS", 21, "UPS", "", "", null, null, null,null),
        PanicConfessionTime: new Card("PanicConfessionTime", 22, "PanicConfessionTime", "", "", null, null, null, null, true),
        PanicBetweenUs: new Card("PanicBetweenUs", 23, "PanicBetweenUs", "", "", null, null, null,null, true),
        PanicForgot: new Card("PanicForgot", 24, "PanicForgot", "", "", null, null, null, null, true),
        PanicFriend: new Card("Old Ropes down", 25, "Old Ropes", "", "", null, null, null, true),
        PanicMeet: new Card("Old Ropes down", 26, "Old Ropes", "", "", null, null, null, null, true),
        PanicChain: new Card("Old Ropes down", 27, "Old Ropes", "", "", null, null, null, null, true),
        PanicOneTwo: new Card("Old Ropes down", 28, "Old Ropes", "", "", null, null, null, null, true),
        PanicGoAway: new Card("Old Ropes down", 29, "Old Ropes", "", "", null, null, null, null, true),
        PanicParty: new Card("Old Ropes down", 30, "Old Ropes", "", "", null, null, null, null, true),

    };

    function findCardByNum(num) {
        for (i in Cards)
            if (Cards[i].num == num) return Cards[i];
        return Cards.UnknownAction;

    }

    class CardInHand {
        constructor(player, place, num) {
            this.name = name;

        }


    }

    class TextLabels {

        constructor(id, text, x=0, y=undefined, c = "#000", s=1, t=3000) {
            this.id = id;
            this.text = text;
            this.x = x;
            this.y = y;
            this.c = c;
            this.s = s;
            this.t = t;
            //this.h = h;
            //this.callback = callback;
            TextLabels.labels.set(id, this);
            //this.p = p;
            //this.p1 = p1;
            //setTimeout()
            if (t > 0) setTimeout(() => {
                TextLabels.Delete(id);
            }, t);


        }
        static lastY = 230;
        static offsetY = 0;
        static labels = new Map();

        static ErrorLabelText(text) {

            new TextLabels(TextLabels.labels.size, text);//, 0, TextLabels.lastY);


        }

        static DrawAll(ctx, e) {
            let offset = 0;
            TextLabels.labels.forEach((v, k) => { offset = v.Draw(ctx, e, offset) });
            //TextLabels.lastY -= 17;
        }

        static Delete(id) {
            TextLabels.labels.delete(id);

        }

        static DeleteAll() {
            TextLabels.labels.clear();
        }

        Draw(ctx, e, offset=0) {
            let y = this.y;
            let l = 0;
            if (this.y == undefined) y = TextLabels.lastY;
            y += offset;
            ctx.save();
            ctx.translate(this.x, y);
            ctx.fillStyle = this.c;
            ctx.font = '16px serif';
            ctx.scale(this.s, this.s);
            if (this.text!=undefined)for (var s of this.text.split("\n")) ctx.fillText(s, 0, l += 17);
            //TextLabels.lastY = y;
            ctx.restore();
            //ctx.fillText(this.text);//, 3, this.text.length);
            return l + offset;

        }


    }


    class Player {
        constructor(name, num, isMe, cards, state, Phase, QuarantineCount = 0) {
            this.name = name;
            this.playername = name;
            this.place = num;
            this.isMe = isMe;
            this.cards = cards;
            this.Infected = false;
            this.Thing = false;
            this.state = state;
            this.QuarantineCount = QuarantineCount;
            this.selected = null;
            this.selectedCard = null;
            this.Phase = Phase;
            this.moveOneCard = false;
            this.move = null;
            this.x = 0;
            this.y = 0;
            this.transform = {};
            this.isNear = false;
            this.cardForExchangeOut = null;

        }

        get isNear_() {

            return game.isNearOpponent(this);
        }

        toString() {
            return this.playername;
        }


        get PanicCount() {
            return this.cards.filter(v => v.card.isPanic == true).length;

        }
        get InfectCount() {
            return this.cards.filter(v => v.card == Cards.Infect).length;

        }
        get isCardMovableNow() {

            if (this.Phase == Phases.Nothing) return false;
            if (this.selectedCard == null) return false;
            if (this.Phase == Phases.Action) {
                return this.selectedCard.card.isCardMovableForAction(this);
            }
        }

        get isEndTurnExchange() {
            return (this.Phase == Phases.Exchange && this.state == States.SelectCard && this.cards.length < 5);
        }

        get isMyTurnToDefend() {
            return (this.Phase == Phases.Answer && this.state == States.DefendFireSelectCard && this.cards.length < 5);
        }
        get isStartTurnExchangeIn() {
            return (this.Phase == Phases.Answer && this.state == States.IncomeExchange && this.cards.length < 5);
        }

        get isAction() {

            return (this.Phase == Phases.Action);
        }

        get isNowMyTurn() {
            return this.Phase == Phases.Action;
        }

        get isINeedGetCard() {

            return this.Phase == Phases.Action && this.state == States.SelectCard && this.cards.length < 5;
        }


        Draw(ctx, e, actions) {
            let selectNearPlayersCards = false;
            let actionOnSelectSecondCard = undefined;
            let selectPlayer = false;
            let OnSelectPlayer = undefined;
            let HiLightRLPlayers = false;
            actions.forEach((v) => {
                if (v.selectNearPlayersCards != undefined) selectNearPlayersCards = v.selectNearPlayersCards;
                if (v.actionOnSelectSecondCard != undefined) actionOnSelectSecondCard = v.actionOnSelectSecondCard;
                if (v.selectPlayer != undefined) selectPlayer = v.selectPlayer;
                if (v.OnSelectPlayer != undefined) OnSelectPlayer = v.OnSelectPlayer;
                if (v.HiLightRLPlayers != undefined)HiLightRLPlayers = v.HiLightRLPlayers;
            });

            let errortext = '';
            this.transform = ctx.getTransform();
            this.x = this.transform.e;
            this.y = this.transform.f
            //x: x * invMat.a + y * invMat.c + invMat.e,
            // y: x * invMat.b + y * invMat.d + invMat.f
            let lm = (this.cards.length - 1) / 2;

            if (selectPlayer == true) {
                if (e != undefined) {
                    let p = ctx.getWindowToCanvas(e);
                    if (p != undefined)
                        if (p.x > -2 * Card.width && p.x < 5 * Card.width && p.y > -20 && p.y < 250) errortext = this.OnPlayerSelect(OnSelectPlayer, HiLightRLPlayers);
                }
            }

            if (e != undefined && !this.moveOneCard && !selectNearPlayersCards && !selectPlayer) {

                //if (this.isMe)
                this.selected = null; this.selectedCard = null; this.move = null;//reset old selection
                //else { this.selected = null; this.selectedCard = null; }

            }




            this.cards.forEach((v, z) => {
                let i = z - lm;
                let h = 35;
                let mx = 0;
                ctx.save();

                ctx.strokeStyle = "#af2";
                //if (this.isMe)
                if (this.selected == z || v.ShowTo == true) { h = -5; ctx.scale(1.2, 1.2); mx = 10; ctx.strokeStyle = "#a00"; }
                ctx.translate(i * 111 - mx, h);

                if (e != undefined) {
                    let c = ctx.getWindowToCanvas(e);
                    if (this.moveOneCard && this.selected == z && this.isMe) {
                        this.move = { x: c.x - 20, y: c.y - 20 };
                        c.x = 1;
                        c.y = 1;

                    }



                    if (c != undefined)
                        if (c.x > 0 && c.x < 90 && c.y > 0 && c.y < 150) {
                            errortext = this.OnCardSelect(v, z, actionOnSelectSecondCard, selectNearPlayersCards);

                        }
                }

                if (this.isMe && this.selected == z && this.move != null && this.moveOneCard) {
                    ctx.translate(this.move.x, this.move.y);
                } else ctx.rotate(i / 50 * Math.PI);


                v.card.Draw(ctx);

                ctx.strokeStyle = "#af2";

                ctx.restore();
            });

            ctx.strokeStyle = "#005";
            ctx.font = 'bold 48px serif';
            ctx.fillText(this.name, 20, 20);
            ctx.strokeText(this.name, 20, 20);
            ctx.stroke();

            if (errortext != '') TextLabels.ErrorLabelText(errortext);



        }

        OnPlayerSelect(callback, isNearOnly) {
            if (this.isMe) return 'Select other player!';
            if (!this.isNear && isNearOnly == true) return 'Select near player!';

            if (callback != undefined) callback(this);


        }


        OnCardSelect(v, z, actionOnSelectSecondCard, selectNearPlayersCards) {


            if (game.me.isMyTurnToDefend && !this.isMe) return 'Select your card for defend from fire!!!';
            if (game.me.isMyTurnToDefend && this.isMe) {


            }

            if (game.me.isStartTurnExchangeIn && !this.isMe) return 'Select your card for exchange or decline!!!';
            if (game.me.isStartTurnExchangeIn && this.isMe) {
                let isInExchange = undefined;
                let c = v.card.GetAnswerArray(this, game.opponent);

                c.forEach((i) => {
                    if (i.isInExchange != undefined) isInExchange = i.isInExchange;
                });
                
                if (isInExchange == undefined || isInExchange == false) return 'Select other card for exchange or decline!!!';
            }

            if (game.me.isEndTurnExchange && !this.isMe) return 'Select your card for exchange!!!';
            if (game.me.isEndTurnExchange && this.isMe) {
                let isOutExchange = undefined;
                let c = v.card.GetExchangeArray(this, game.opponent);

                c.forEach((i) => {
                    if (i.isOutExchange != undefined) isOutExchange = i.isOutExchange;
                });
                if (isOutExchange == undefined || isOutExchange==false) return 'Select other card for exchange!!!';
                //outChangeAction(v);

            }

 
            
            if (this.PanicCount > 0 && !v.card.isPanic)                return 'Select panic!!!';

            if (selectNearPlayersCards && !this.isMe) {
                if (this.isNear) {
                    this.selected = z; this.selectedCard = v;
                    if (actionOnSelectSecondCard != undefined) actionOnSelectSecondCard(this.playername, v);
                    return '';
                }
                return 'Select only near player card';
            }

            this.selected = z; this.selectedCard = v; v.card.RemoveOldAddNewButtons(this, v)
            return '';
        }


    };


    class Game {


        constructor(guid) {

            this.guid = guid;
            //            this.players =
            this.isStarted = false;
            this.players = [new Player("Stay away game", 0, true, [], States.SelectCard, Phases.Action, 0)];
            this.selectedOtherCardPlace = null;
            this.me = this.players[0];
            this.Deck = new Deck(Cards.UnknownAction, 4, 2);
            this.moveOneCard = false;
            this.gameDirection = Direction.CW;
            this.selectedOpponent = null;
            this.opponent = null;
            this.nextplayer = null;
            this.exchange = [];
            this.ViewlineTo = null;
            this.ShowOneCard = null;
            this.gamelog = [];

        }


        findPlayerByNum(num) {
            for (var p of this.players) if (p.place == num) return p;
            return null;
        }

        parseGamelog(message) {
            let result = "";
            this.gamelog = message.gamelog;
            this.gamelog.forEach((v) => { result = result+v+"\r" });

            let q = document.getElementById("gamelog");
            q.value = result;
            q.scrollTop = q.scrollHeight;

        }


        parsePlayerList(message) {
            let j = 0;
            let selected = this.me.selected;
            //if (this.me.selected!=null) return;//заглушка чтобы карты не сбрасывались с мышки когда поступает пакет от сервера

            this.ShowOneCard = null;
            this.exchange = [];
            this.players = [];
            message.playerlist.forEach((v, i) => {
                if(v.isDead==true)return;
                for (j in v.cards) {
                    //if
                    v.cards[j].card = findCardByNum(v.cards[j].cardnum); // тут приходит пакет с реквизитами
                    if (v.cards[j].toPlayer != undefined && v.cards[j].ShowTo == true) this.ShowOneCard = { playername: v.cards[j].toPlayer, cardplace: v.cards[j].cardplace };

                }
                let p = new Player(v.playername, v.num, i == 0, v.cards, findStateByNum(v.state), findPhaseByNum(v.phase));

                p.Thing = v.thing;
                p.Infected = v.Infected;
                this.players.push(p);

                if (v.num == message.opponent) this.opponent = p;
                if (v.exchange == null) return;
                this.exchange.push({ currentplayer: p, nextplayer: v.exchange.nextplayer, card: findCardByNum(v.exchange.card) });

            });

            this.me = this.players[0];///
            this.nextplayer = message.nextplayer;
            this.me.opponent = this.opponent;
            if (message.deck != undefined) {
                this.Deck = new Deck(findCardByNum(message.deck.card), message.deck.deckCount, message.deck.dropCount, message.deck.drop, message.deck.table);

                this.isStarted = true;

            }


            this.players.forEach((v) => { v.isNear = this.isNearOpponent(v) })

        }



        drawText(ctx, x, y, text) {

            ctx.fillStyle = "#003";
            ctx.font = '16px serif';
            for (var s of text.split("\n")) ctx.fillText(s, x, y += 17);

        }




        isNearOpponent(player) {
            let pldist = Math.abs(player.place - this.me.place);
            return pldist == 1 || pldist == this.players.length - 1;

            //return player == this.players[1] || player == this.players[this.players.length - 1];

        }

        DrawPlayersCards(ctx, e, v, HiLightRLPlayers, HLOpponent, i, actions) {

            let s = 260;
            if (v == this.me) v.moveOneCard = this.moveOneCard;
            if (v != this.me) s = 750;
            let ang = 2 * Math.PI * (i / (this.players.length + this.players.length / 5));// + 2.5));
            if (v != this.me) ang += 0.5;
            let x = Math.cos(ang) * s;
            let y = - Math.sin(ang) * s;
            //v.x = x;
            //v.y = y;
            ctx.save();

            if (v != this.me) ctx.scale(0.5, 0.5);
            ctx.translate(y, x);
            ctx.rotate(ang);

            if (this.isNearOpponent(v) && HiLightRLPlayers == true && v != this.me || (HLOpponent && v.place == this.nextplayer)) {
                ctx.fillStyle = "#003";
                ctx.strokeStyle = "#a02";
                ctx.roundRect(-2 * 95, -20, 5 * 95, 250, 20).stroke();
            }

            v.Draw(ctx, e, actions);


            this.exchange.filter((a) => {
                if (a.nextplayer != v.place) return false;

                ctx.save();
                ctx.translate(-10, -200);
                a.card.Draw(ctx);
                ctx.restore();


            });


            ctx.restore();

        }

        drawStatePhase() {

            let stateText = "";
            if (this.opponent != null) stateText = "Now turn " + this.opponent;
            let phaseText = "";
            switch (this.me.state) {
                case States.IncomeExchange:
                    stateText = "Select your card";

                    break;
                case States.SelectCard:
                    stateText = "Select your card";
                    switch (this.me.Phase) {
                        case Phases.Exchange:
                            phaseText = "for exchange";
                            break;
                        case Phases.Action:
                            phaseText = "for action";
                            break;
                        case Phases.Answer:
                            phaseText = "for answer";
                            break;

                    }


                    break;

            }
            new TextLabels("state", stateText, -210, 220, "#000", 2, 0);
            new TextLabels("phase", phaseText, -210, 250, "#000", 2, 0);


        }

        Draw(ctx, e, w, h) {
            ctx.clearRect(0, 0, w, h);
            ctx.save();
            ctx.translate(w / 2, h / 2);


            if (this.me.selectedCard == null || this.me.Phase == Phases.Nothing || !(this.me.state == States.SelectCard || this.me.state == States.IncomeExchange || this.me.state == States.DefendFireSelectCard)) Button.DeleteAll()
            this.drawStatePhase();

            let HLOpponent = false;
            if (this.me.Phase == Phases.Exchange) {
                //this.drawText(ctx, -10, -190, "Select card \nfor exchange");
                HLOpponent = this.nextplayer != null;
            }

            let HiLightRLPlayers = false;
            //let selectNearPlayersCards = false;
            let c = [];
            // let ex = this.me.selectedCard.GetExchangeArray()
            if (this.me.selectedCard != null) {
                if (this.me.isNowMyTurn) {
                    c = this.me.selectedCard.card.GetActionArray(this.me);

                    c.forEach((v) => {
                        if (v.HiLightText != undefined) this.drawText(ctx, -10, 20, v.HiLightText);
                        if (v.HiLightRLPlayers == true) HiLightRLPlayers = true;
                        //if (v.selectNearPlayersCards != undefined) selectNearPlayersCards = v.selectNearPlayersCards;
                    });

                } else { }
            }


            let central = this.me.place;

            this.players.sort((a,b)=>a.place-b.place).forEach((v, i) => {
                let newplace = v.place - central;
                if (newplace < 0) newplace = newplace + this.players.length;
                this.DrawPlayersCards(ctx, e, v, HiLightRLPlayers, HLOpponent, newplace, c);
            });





            ctx.save();
            ctx.translate(-100, -200);
            Button.DrawAll(ctx, e);
            ctx.restore();

            ctx.save();
            ctx.translate(-20, -200);
            this.Deck.Draw(ctx, e);
            ctx.restore();


            ctx.save();
            ctx.translate(-10, -200);
            TextLabels.DrawAll(ctx, e);
            ctx.restore();

            ctx.restore();

            this.exchange.forEach((a) => {
                //    currentplayer: p, nextplayer: v.exchange.nextplayer, card: findCardByNum(v.exchange.card)
                let n = this.findPlayerByNum(a.nextplayer);
                if (n == null) return;
                let p = a.currentplayer;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(n.x, n.y);
                ctx.stroke();
                ctx.closePath();



            });

        }

    };




    function findPhaseByNum(num) {
        for (i in Phases)
            if (Phases[i] == num) return Phases[i];
        return Phases.Nothing;

    }

    function findStateByNum(num) {
        for (i in States)
            if (States[i] == num) return States[i];
        return States.Nothing;

    }

    //----------------------------------------------------------------
    const Phases = {
        Nothing: 0,
        Exchange: 1,
        Action: 2,
        Answer: 3

    };

    const Direction = {
        CW: 0,
        CCW: 1
    };

    const States = {
        Nothing: 0,
        SelectCard: 2,
        OutgoingExchange: 3,
        IncomeExchange: 4,
        PerseveranceSelectCard: 5,
        SelectPlayer: 6,
        DefendFireSelectCard: 7,
        Panic: 8


    };



    //---------------------------------------------------------
    var wsUrl = location.origin.replace(/^http/, 'ws')
    let websocket = null;//new WebSocket(wsUrl);

    function startWS() {
        websocket = new WebSocket(wsUrl);

        websocket.mysend = function (message) {

            if (websocket.OPEN == websocket.readyState) {
                websocket.send(message); return;
            }

            window.setTimeout(() => {
                websocket.mysend(message);
            }, 1000);

        }

        websocket.senddata = function (data) {
            let message = JSON.stringify(data).toString();
            websocket.mysend(message);
        }



        websocket.onopen = (evt) => { console.log(evt) };
        websocket.onclose = function (evt) {
            console.log(evt);
            if (evt.code == '1006') { startWS(); start(); return };
            alert(evt.reason);
            startWS();
            //game = null;
        };
        websocket.onerror = function (evt) { console.log(evt) };

        websocket.onmessage = function (evt) {
            console.log(evt.data);
            document.getElementById("startgamebutton").hidden = false;
            let message = JSON.parse(evt.data);
            if (message.messagetype == 'playerguid') {
                game = new Game(message.guid);
                document.cookie = evt.data;
                //document.getElementById("loginbutton").hidden = true;
                //document.getElementById("login").setAttribute("readonly", true);//hidden = true;
                return;
            }


            if (message.messagetype == 'playerlist') {
                game.parsePlayerList(message);
                return;
            }
            if (message.messagetype == 'gamelog') {
                game.parseGamelog(message);
                return;
            }

        };
        autoping();

    }




    var RAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
        callback();
        window.setTimeout(callback, 200);
    };


    let game = new Game(123);
    var canvas = document.getElementById("canvas");
    canvas.height = window.innerHeight;
    canvas.width = window.innerWidth;

    var ctx = canvas.getContext("2d");
    ctx.globalCompositeOperation = 'destination-over';
    var w = canvas.width;
    var h = canvas.height;


    window.addEventListener("mousemove", function (event) {
        if (game == null) return;
        if (game.moveOneCard)
            render(event);
    });

    window.addEventListener("mousedown", function (event) {
        if (game == null) return;
        render(event);
        if (game.me.selected != null) game.moveOneCard = game.me.isCardMovableNow;

    });

    window.addEventListener("mouseup", function (e) {
        if (game == null) return;
        game.moveOneCard = false;
    });

    /*
    // отправить сообщение из формы publish
    document.forms.publish.onsubmit = function () {
        var outgoingMessage = this.message.value;

        socket.send(outgoingMessage);
        return false;
    };
    */
    function BurnPlayer(player) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "actionBurnPlayer";
       
        p.bymycardplace = game.me.selectedCard.cardplace;
        p.otherPlayerName = player.name;
        //console.log(p);
        websocket.senddata(p);
       // game.me.selected = null;

    }

    function DefendFromFire(pl) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "actionDefendFromFire";

        p.bymycardplace = pl.cardplace;
        
        websocket.senddata(p);
       // game.me.selected = null;



    }

    function showAllCards(place) {

        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "actionShowAllCards";
        p.place = place.cardplace;//
        //console.log(place);
        websocket.senddata(p);

    }


    function rejectExchange(place) {



    }

    function dropcard(place) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "actionDropCard";
        p.place = place.cardplace;//
        console.log(place);
        websocket.senddata(p);

    }

    function ShowMeCard(otherplayername, place) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "actionShowMeCard";
        p.place = place.cardplace;//
        p.bymycardplace = game.me.selectedCard.cardplace;
        p.otherPlayerName = otherplayername;
        //console.log(p);
        websocket.senddata(p);
       // game.me.selected = null;

    }

    function exchangecard(place) {
        if (States.IncomeExchange == game.me.state) return exchangecardin(place);
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "outExchangeCard";
        p.place = place.cardplace;
        p.opponent = game.opponent.playername;
        websocket.senddata(p);
    }

    function exchangecardin(place) {
        let p = JSON.parse(document.cookie);
        p.messagetype = 'playeraction';
        p.action = "inExchangeCard";
        p.place = place.cardplace;
        p.opponent = game.opponent.playername;
        websocket.senddata(p);
    }

    function start() {
        let loginelement = document.getElementById("login");
        let roomElement = document.getElementById("room");
        if (document.cookie != "") {
            try {
                let p = JSON.parse(document.cookie);
                p.messagetype = 'newplayer';
                p.numofPlayers = 1;
                loginelement.value = p.playername;
                roomElement.value = p.roomname;

                game = new Game(p.guid);
                websocket.senddata(p);
                return;
            } catch { }
        }




    }





    function update() {

        render();

        RAF(update);
    }



    function render(e) {
        if (game == null) return;
        // ctx.clearRect(0, 0, w, h);
        //  ctx.save();
        //  ctx.translate(w / 2, h / 2);
        game.Draw(ctx, e, w, h);
        //  ctx.restore();
    }

    function sendQuery() {
        let q = document.getElementById("query").value;
        websocket.senddata({ messagetype: "query", query: q });

    }

    function sendLogin() {
        let loginelement = document.getElementById("login");
        let p = {
            messagetype: 'newplayer',
            roomname: document.getElementById("room").value,
            password: '1',
            numofPlayers: 1,
            playername: loginelement.value,
            guid: game == null ? '' : game.guid

        };

        websocket.senddata(p);
        document.getElementById("startgamebutton").hidden = false;
    }



    function startGame() {

        try {
            let p = JSON.parse(document.cookie);
            p.messagetype = 'startgame';
            //p.
            websocket.senddata(p);
            //document.getElementById("logindiv").hidden = true;
            //document.getElementById("startgamebutton").hidden = true;

        } catch { }
    }

    function gameLoop() {

        if (game == null) return;
        if (game.isStarted == false) return;
        let p = JSON.parse(document.cookie);
        //p.messagetype = 'playeraction';
        //if (game.me.isINeedGetCard) p.action = "getOneCardfromDeckForAction";
        //websocket.senddata(p);

    }


    function autoping() {
        window.setTimeout(() => {

            gameLoop();
            let ping = JSON.stringify({ messagetype: 'ping' }).toString();
            //console.log(ping);
            if (websocket.OPEN == websocket.readyState)
                websocket.send(ping);
            autoping();

        }, 2000);
    }

    startWS();

    start();

    update();

       // <div id="logindiv">
       // <input id="login">player</input><button onclick="sendLogin()">Login</button>
      //  </div>
           //         <button id ="startgamebutton" onclick="startGame()">Startgame</button>
</script>

</html>